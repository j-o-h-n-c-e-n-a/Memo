## データ構造
1. 配列と文字列
	* Array
		+ メリット：インデックスを通して高速にアクセス可能。末尾のデータ挿入、削除は高速
		+ デメリット：データが大きい場合に大量のメモリを消費する。インデックス中間部分へのデータの挿入、削除が遅い 
2. 連結リスト
	* Linked List 
		+ メリット：データをどの部分であっても挿入、削除が容易なためリサイズが容易
		+ デメリット： リンクを辿ってアクセスするためデータのアクセスが遅い。次のデータのアドレスを保持するためデータのサイズがその分大きくなる
3. スタックとキュー
	* Stack
		+ メリット：データの取得は高速。再帰的な処理などと相性が良い
		+ デメリット：何も考えずに使うとStack Over Flowのようなメモリリークを起こす。中間のデータにはアクセス不可
	* Queue
		+ メリット：データの取得は高速。ファイルの入出力やWEBからのデータ入出力などと相性が良い
		+ デメリット：スタックと同様で何も考えずに使うとメモリリークを起こす。中間のデータにはアクセス不可
4. 木とグラフ
	* Binary Tree
		+ メリット：挿入、更新がLinked Listのように高速にでき、なおかつ検索も早い
		+ デメリット：深さが平衡していないと性能に悪影響を与える
	* Trie
		+ メリット：辞書など大量のデータパターンを高速に扱いたい場合に使用
		+ デメリット：メモリ消費量が多い
	* Graph 
		+ メリット：TreeやTrieでは扱えない循環型のデータを扱う時に使用。nodeごとのコストを割り振ることもできるので最適なルートやコストを求める問題にも適用可能
		+ デメリット： 複雑な為、扱うのが難しい
	* 有向グラフ
	* 無向グラフ
	* 重み付きグラフ
## 考え方とアルゴリズム
5. ビット操作
6. 数学と論理パズル
	* 素数
	* 最大公約数、最小公倍数
7. オブジェクト指向設計
8. 再帰と動的計画法
	* ナップザック問題
9. スケーラビリティとシステムデザイン
10. ソートと探索
	* ソート
		+ クイックソート：一般的に高速なアルゴリズムのため使用される機会が多い 
		+ マージソート：並列で処理が可能なため、メモリとCPUの並列数が豊富な場合に使用
		+ 挿入ソート：マージソートやクイックソートに比べ、データの状態に依存していないため安定的にソート可能。主に小さなデータやすでにほとんどソート済みのデータに使用 
		+ カウンティングソート：シンプルかつ高速なソート。メモリが豊富で扱うデータとマッチしていればこの手法が一番良い
	* 探索
		+ 深さ優先探索
		+ 幅優先探索
	* 探索範囲の限定
		+ 貧欲法
		+ 2分探索
		+ ハミルトン
11. テスト
## 知識ベース
* C,C++
* Java
* Python
* データベース
* スレッドとロック
## 応用問題
* フラグ管理
* 
## 典型問題
* FizzBuzz
* 最短経路問題
	+ ダイクストラ法

## Next
* 数学
* トポロジカルソート
* ハッシュテーブルの衝突処理
* ラビンカーブ文字列検索
* AVL木
* 赤黒木
* マップリデュース

## 問題提供サイト
* [AtCoder](https://beta.atcoder.jp/contests/abs/tasks/practice_1)
* [TOPSIC](http://noimin.hatenablog.com/entry/2017/12/16/230900)
* [AOJ: Online Programming Challenge](http://judge.u-aizu.ac.jp/onlinejudge/index.jsp)

## 解説等
* [AtCoder に登録したら次にやること](https://qiita.com/drken/items/fd4e5e3630d0f5859067)
* 