## データ構造
1. 配列と文字列
	* Array
		+ メリット：インデックスを通して高速にアクセス可能。末尾のデータ挿入、削除は高速
		+ デメリット：データが大きい場合に大量のメモリを消費する。インデックス中間部分へのデータの挿入、削除が遅い 
2. 連結リスト
	* Linked List 
		+ メリット：データをどの部分であっても挿入、削除が容易なためリサイズが容易
		+ デメリット： リンクを辿ってアクセスするためデータのアクセスが遅い。次のデータのアドレスを保持するためデータのサイズがその分大きくなる
	* バケット法
3. スタックとキュー
	* Stack
		+ メリット：データの取得は高速。再帰的な処理などと相性が良い
		+ デメリット：何も考えずに使うとStack Over Flowのようなメモリリークを起こす。中間のデータにはアクセス不可
	* Queue
		+ メリット：データの取得は高速。ファイルの入出力やWEBからのデータ入出力などと相性が良い
		+ デメリット：スタックと同様で何も考えずに使うとメモリリークを起こす。中間のデータにはアクセス不可
4. 木とグラフ
	* Binary Tree
		+ メリット：挿入、更新がLinked Listのように高速にでき、なおかつ検索も早い
		+ デメリット：深さが平衡していないと性能に悪影響を与える
	* Trie
		+ メリット：辞書など大量のデータパターンを高速に扱いたい場合に使用
		+ デメリット：メモリ消費量が多い
	* Graph 
		+ メリット：TreeやTrieでは扱えない循環型のデータを扱う時に使用。nodeごとのコストを割り振ることもできるので最適なルートやコストを求める問題にも適用可能
		+ デメリット： 複雑な為、扱うのが難しい
	* 有向グラフ
	* 無向グラフ
	* 重み付きグラフ
## 考え方とアルゴリズム
5. ビット操作
6. 数学と論理パズル
	* 素数
	* 最大公約数、最小公倍数
7. オブジェクト指向設計
8. 再帰と動的計画法(DP)
	* ナップザック問題
9. スケーラビリティとシステムデザイン
10. ソートと探索
	* ソート
		+ クイックソート：一般的に高速なアルゴリズムのため使用される機会が多い 
		+ マージソート：並列で処理が可能なため、メモリとCPUの並列数が豊富な場合に使用
		+ 挿入ソート：マージソートやクイックソートに比べ、データの状態に依存していないため安定的にソート可能。主に小さなデータやすでにほとんどソート済みのデータに使用 
		+ カウンティングソート：シンプルかつ高速なソート。メモリが豊富で扱うデータとマッチしていればこの手法が一番良い
	* 探索
		+ 深さ優先探索(DFS)
			- 全通りを列挙し、結果をまとめる必要がある場合
			- 文字列などを探索するときに、辞書順最小であることが求められている場合
			- 再帰関数
			- 部分和問題
		+ 幅優先探索(BFS)
			- 始点から最も近いものを求めたい
			- 探索範囲自体は広いもののある程度近くに求めたい解が存在することが分かっている
	* 探索範囲の限定
		+ 貧欲法
		+ 2分探索
		+ ハミルトン
11. テスト
## 知識ベース
* C,C++
* Java
* Python
* データベース
* スレッドとロック
## 応用問題
* フラグ管理
* 
## 典型問題
* シミュレーション
	+ 設問にあることをただやるだけ
* 全探索
	+ 全パターンを調べて最も良い解を探すもの
		- 回文
		- 暗号文
		- グラフ
* データ構造
	+ スタック
		- 後入れ先出し
		- 深さ優先探索：実際にはスタックより再帰関数を使うことが多い
	+ キュー
		- 先入先出
		- 幅優先探索
	+ デック
		- Pythonでは、collections.dequeを使用したほうが速いらしい
		- appendで追加、popleftでキュー取り出し、popでスタック取り出し
	+ PriorityQueue
		- 最良優先探索が可能
* FizzBuzz
```python:サンプル
	for i in range(1, 101):
		if i % 15 == 0:
			print("FizzBuzz")
		elif i % 3 == 0:
			print("Fizz")
		elif i % 5 == 0:
			print("Buzz")
		else:
			print(i)
```
* フィボナッチ数列
```python:サンプル
	a=[0,1]
	exec('a+=[a[-1]+a[-2]];'*int(input()))
	print(a[:-2])
```

* 最短経路問題（最良優先探索）
	+ ダイクストラ法
* Greedy
## Next
* 数学
	+ 10進法表記の扱い方
		- 各桁を10で割った答えと余りを使う
* トポロジカルソート
* ハッシュテーブルの衝突処理
* ラビンカーブ文字列検索
* AVL木
* 赤黒木
* マップリデュース
* オイラー閉路
	あるグラフにおいて、全ての辺をちょうど一度だけ通るような路
* 最小有向木
* 分岐限定法
* グリッド
* 
### 二分探索
```python:サンプル
	import bisect
	listA=[1,2,5,2,4,6,7,8,6,56,3,56,76,34,32,2,6,0,32,6,0] 
	listA.sort()
	zeroindex=bisect.bisect_right(listA,0) #ソートされたリスト内で0の場所を探し、右側Indexを返す
	clearlistA=listA[zeroindex:]#0以下が存在しないリストを得る
	print(clearlistA)
```
### 素数判定
```python:サンプル
	def primeJudge(p):
	p = abs(p)
	if p == 2:
		return True
	if p < 2 or p & 1 == 0:
		return False
	return pow(2, p-1, p) == 1
```

## 問題提供サイト
* [AtCoder](https://beta.atcoder.jp/contests/abs/tasks/practice_1)
* [TOPSIC](http://noimin.hatenablog.com/entry/2017/12/16/230900)
* [AOJ: Online Programming Challenge](http://judge.u-aizu.ac.jp/onlinejudge/index.jsp)

## 解説等
* [AtCoder に登録したら次にやること](https://qiita.com/drken/items/fd4e5e3630d0f5859067)
* 