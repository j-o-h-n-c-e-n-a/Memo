## cloudskillsboost
* [cloudskillsboost](https://www.cloudskillsboost.google/course_templates/266)
* [クラウド企業のリーダー](https://cloud.google.com/training/business)
* [Business Transformation with Google Cloud](https://www.cloudskillsboost.google/course_templates/62)
* [Google Cloud Fundamentals for AWS Professionals](https://www.cloudskillsboost.google/course_templates/38?utm_source=gcp_training&utm_medium=website&utm_campaign=cgc)
* [Google Cloud Platform Fundamentals: Core Infrastructure 日本語版](https://www.cloudskillsboost.google/course_templates/60)
* [Google Developer Essentials](https://www.cloudskillsboost.google/quests/86?catalog_rank=%7B%22rank%22%3A24%2C%22num_filters%22%3A5%2C%22has_search%22%3Afalse%7D)
* [Cloud Engineering](https://www.cloudskillsboost.google/quests/66?catalog_rank=%7B%22rank%22%3A8%2C%22num_filters%22%3A5%2C%22has_search%22%3Afalse%7D)
* [Google Cloud Big Data and Machine Learning Fundamentals](https://www.cloudskillsboost.google/course_templates/3)
1. [Create and Manage Cloud Resources](https://www.qwiklabs.com/quests/120?locale=ja) 
2. [Perform Foundational Infrastructure Tasks in Google Cloud](https://www.qwiklabs.com/quests/118?locale=ja)
3. [Set Up and Configure a Cloud Environment in Google Cloud](https://www.qwiklabs.com/quests/119?locale=ja)
4. [Build and Secure Networks in Google Cloud](https://www.qwiklabs.com/quests/128?locale=ja)
5. [Deploy to Kubernetes in Google Cloud](https://www.qwiklabs.com/quests/116?locale=ja)


## Other
* [](https://developers.google.com/products)
* [社内Kubernetesトラブルシュート](https://weseek.co.jp/tech/282/)
* [Azure Kubernetes Services (AKS) における Kubernetes の中心概念](https://docs.microsoft.com/ja-jp/azure/aks/concepts-clusters-workloads?ocid=eml_pg201266_gdc_comm_az&mkt_tok=MTU3LUdRRS0zODIAAAGEudmHhiLYlgs9FHNvqEmibizAhIsv0zK2sfGx9OZeNBZ3Rn-y2fwa4WkYecCDFOj0p5SVjKKSq_gChofv0n6Nv__QehJThaNe7F1MSsWjK_Z0RhC1m6zKoGw)
* [](https://cloudonair.withgoogle.com/events/try-together-0602?mkt_tok=ODA4LUdKVy0zMTQAAAGEu4k1vd5l4WFLgWAEL9JQ1wAD_qxqzCfLI7Y7aybfdsIRUKQS6dwvMG53E7TKWNWWDHjangyqssx9cEQN--DHMvGorIV49DQrooKySioZIK0KvgS02w)
* [](https://future-architect.github.io/articles/20200202/)
* []()


## Business Transformation with Google Cloud
### 1. クラウド技術がビジネスに革命をもたらす理由
* 驚異的な計算能力
* 生産性向上と自動化 
* 認識、分類、予測、推奨 
### 2. イノベーション文化を醸成する
* 環境作りが大事
* 本質的に文化とビジネス慣習の融合、あるいは人とプロセスの混合
* Google の10倍の原則の話
* X10のひと案がうまくいかなかった場合は、素早く失敗する
* プロトタイプ開発
* イノベーションの考え方についての質問
    + あなたの目的は何ですか あなたのチームの目的は何ですか あなたの組織の目的は何ですか
    + 今日から使える原則や、革新的な思考や実験を促すような簡単な変更点は何でしょうか
    + もしあなたが指導的立場にあるのなら、チームがより快適にアイデアを共有できるよう、あなたのマネジメントスタイルを調整する方法は3つありますか
    + 最初のドラフトを共有してフィードバックを受けながら反復する代わりに、アイデアを完成させるのにどれくらいの時間をかけていますか
### 3. 理想的なビジネス変革の課題を定義する
* 「まっすぐ」、「月に向かって」、「志を高く」する
* データの価値を引き出すには、まずデータエコシステムのマッピングから
* 
### 可用性、セキュリティ、コンプライアンスで信頼を築く
* プライバシー
    + データの保存場所を明示的に設定できます
    + すべてのデータセンターの所在地を公開
    + 政府機関に対し、あなたのデータやあなたのデータを保存している当社のサーバーへのバックドアや違法なアクセスを一切許可しておらず、無効な政府要請を拒否しています
* セキュリティ
    + 脅威
        - フィッシング攻撃
        - 自然災害
        - ウィルス
        - サードパーティ製ソフトウェア
    + 対策
        - 階層防御
        - ゼロトラスト
        - 分散
        - 暗号化
        - システム監視体制
        - 多要素認証
* コンプライアンス
    +  ISO 27001、ISO 27017、ISO 27018 の認証
    + 各国政府の規制（GDRP）
* 信頼性
#### 責任共有モデル
### 変革のためのビジネスケースを構築する
    構築しようとしているソリューションの顧客は誰か、もし異なるのであればエンドユーザーは誰か この課題は現在どのように取り組まれているか、そして我々が変革しようとしているビジネスプロセスは何か 小売業の例にもう一度戻りますが、我々が解決しようとしているビジネス上の問題は、顧客をどう再定義する かということ
* 4つの象限
    + 開発とは、時間はかかるが、組織や顧客の既存のビジネス環境の中で実施できるプロジェクトである。 
    + 破壊とは、より速く、根本的に革新的な方法を模索するためのプロジェクトである
* クイックウィン
    + 

## Managing Change when Moving to Google Cloud
    Google Cloud へ移行する際の変更管理

### 企業がクラウドに移行する理由
### クラウド化の課題
* リーダーシップ
* コラボレーション
* 能力
* 人材
* エンゲージメント
### 変革のマネジメント
* Google Cloud Adoption Framework
1. スポンサーシップ
2. チームワーク
3. コミュニケーション
4. 行動
    + 価値観、信念、習慣
5. ピープルオペレーション（人材活用）
### クラウド成熟の旅
    3つの段階
1. 戦術的
* 個別のシステムのコストを削減し、最小限の混乱でクラウドに移行することにある
* これは短期的な目標です
2. 戦略的
* 将来のニーズと規模に基づいて設計・開発された個々のワークロードを管理する、幅広いビジョンを持っています
* これは中期的な目標です
3. 変革的
* クラウド運用が円滑に機能し、クラウドでの作業で収集したデータとインサイトを統合することに目を向けています
* これは長期的な目標です
### 人物を主人公とした叙事詩の進化
### 5つの一般的なクラウドの変更パス
1. リフト＆シフト
2. 移動前に変更する
3. 移動するだけ
4. グリーンフィールドで発明する
5. ブラウンフィールドで発明する
    + 新環境で開発して、旧環境はそのまま実行し、完成に合わせて旧を廃棄する
### Google Cloudの変更管理方法論
* 従業員の準備とパフォーマンス向上
1. 組織内の人材ビジョンと目標とする人材の状態を定義すること、
2. 起きている変化を特定してその影響を理解すること、
3. そして効果的な変更管理方法を確立して実行すること
* クラウド変革の導入計画
1. まず、変化の必要性を評価し、将来のビジョンを定義します。
2. 次に、望ましい状態を計画し、その影響を理解します。
3. そこから、変革の採用管理活動を展開します。
4. そして最後に、フィードバック・ループを通じて成果を最適化します
 * 評価
 * FIT＆GAP
 * コミュニケーション
 * トレーニング計画
 * 定期的な改善

 ## Developing a Google SRE Culture
    サイト信頼性エンジニアリング (SRE) は、開発機能の速度と信頼性に対するリスクのバランスをとるための手法です
 ### Google SRE 文化の発展へようこそ
    このモジュールでは、コースの概要を説明します。このコースがなぜ SRE 文化を取り入れたいと考えている IT およびビジネスリーダーに有益なのか、また各モジュールがどのようなトピックを扱っているのかを学びます
### DevOps、SRE、そしてそれらが存在する理由
    このモジュールでは、DevOps哲学の構成要素、サイト信頼性エンジニアリングが存在するようになった理由、そして組織の誰がSREを実践できるか、実践すべきかを説明します。
* DevOpsとSREのアプローチ
* 開発者と運用者の間にあるギャップの解消
    + 組織のサイロを減らす
        - 共同で本番運用を担当する
        - SLOとエラーマージンを共同で定義し、信頼性基準の決定と作業の優先順位付けを分担
    + 失敗は当たり前と受け止める
        - 心理的安全性
        - インシデントから学ぶ
    + 変化は徐々に実行する
        - プロトタイピング
        - 少人数への展開からはじめる
    + ツールや自動化を活用する
        - 手作業や繰り返しの作業を減らす
    + すべて測定する
        - システムの努力、信頼性、健全性の要素すべてを定量化する
        - 企業には目標設定、透明性、データに基づいた意思決定の文化が必要
### 結果を伴うSLO
    このモジュールでは、組織にとっての SRE の価値と、組織の縦割り構造をなくし、失敗を普通に受け止めるための技術的・文化的な基礎を学びます。トピックとしては、SREの技術的実践として、責めを負わない事後検証、サービスレベル目標（SLO）、エラーバジェット、SREの文化的実践として、責めを負わない、心理的安全、統一ビジョン、コラボレーションとコミュニケーション、知識の共有が含まれます。
* SREの目標は、可用性、レイテンシー、パフォーマンス、キャパシティに常に焦点を当てながら、ソフトウェアやシステムを保護し、サポートし、進化させることである。
* 長期的な成功のためには、文化的・組織的なサポートが必要
* インシデントの対応
* 心理的安全性の文化を促進
    + 心理的安全性とは、自分の考えや質問、懸念、間違いなどを理由に罰せられたり、屈辱を受けたりしないという信念のこと
1. すべての声、すべてのアイデアが重要であることを従業員に理解してもらう
2. 自分の誤りを認識すること質問するように促す
3. 好奇心のお手本を示す
* エラーバジェット：信頼性の低さを許容する量
    + 信頼性の目標値を合意する
    + SLOの設定とパフォーマンス測定
* チームのビジョンを共有
    + コアバリュー、目的、ミッション、戦略、目標など
### 今日より明日を良くする
    継続的かつ漸進的なテストと自動化は、SRE 文化において非常に重要です。このモジュールでは、継続的インテグレーション、継続的デリバリー、カナリアリングといった SRE の技術的概念を、漸進的な変化を実装するという DevOps の柱に関連させながらカバーします。労力と自動化の概念、そして今年の仕事を自動化するという考え方も学びます。また、デザイン思考やプロトタイピングといったSREの文化的プラクティスや、変革を通してチームをサポートする方法についても学びます。
* 継続的インテグレーション
* 継続的デリバリー
* カナリアリング
* デザイン思考
    1. 理解すること
    2. 解決したい問題を見つけるために、ユーザー視点と達成したい目標を照らし合わせて表現する
    3. 新しいアイデアを見つける
    4. プロトタイピング
    5. テスト
* プロトタイピング
* Toil
    + 手作業で反復的なサービスに直接結び付いた仕事
    + 自動化可能、戦術的、永続的的な価値のない、あるいはスケールするサービスの成長に比例して増加します
* 役割分担

### ワークロードの調整
    このモジュールでは、信頼性、労力、そしてモニタリングの概念など、すべてを測定するための SRE の実践について学びます。また、目標設定、透明性、データ駆動型の意思決定といった文化的な基礎についても学びます。
* メトリクス
1. 企業のIT部門は、客観的な方法でサービスの現状を理解することができる。
2. 委員会は、データを分析し、状況を改善するためにとられた措置を特定することができる。
3. IT部門は、企業と協力して、組織全体のbnficeにおいてより良い決定を下すことができる。
* 信頼性
    + 信頼性を測定するためには、適切なSLIを選択することが重要
        - CPU、メモリ、平均負荷
        - イベント定義
    + マニュアルローディング
        - ①繰り返される作業を特定する
        - ②適切な測定単位を選択する
        - ③指標を継続的に監視する
* 効果
    + 削減努力の引き金となる
    + モラル向上
    + プロセスの明確化、標準化
    + 技術力の向上とキャリアアップ
    + トレーニング時間の短縮
    + ヒューマンエラーによる故障の削減
    + ユーザーリクエスト処理の高速化


### 組織における SRE の適用
    このモジュールでは、SRE の原則、実践、文化を採用するための組織の成熟度と準備状況を評価・理解する方法について説明します。また、新しい SRE を採用する際に求めるべきスキルの種類と、現在の従業員のスキルアップの方法についても説明します。最後に、SRE 組織を立ち上げることを検討し始める方法と、SRE への道を歩み続けるために Google クラウド プロフェッショナル サービス チームが提供する追加サポートについてアドバイスを提供します。
#### SRE組織
    Googleでは、開発と運用の連携、実行速度と信頼性のバランス、効果的なコラボレーションの選択など、戦略的な目標を達成するには、まずSLOと誤差の範囲を定義し、それを管理するルールを作らなければならないと考えています
* SREエンジニアリングの文化、原則、慣行をまだ採用していない場合、低い
* SREエンジニアの強力なチームを確立しているか、SRE文化、原則、慣行が広く理解され、実施、採用されている場合に高い
    + 成熟したSRE組織の特徴は、ユーザー満足度と完全に一致する信頼性に重点を置いた、ユーザー中心のSLOがきちんと文書化されていること
#### トレーニング
* 採用
* 運用経験
* モニタリングシステムへの理解
* 生産の自動化
* システムアーキテクチャ
* トラブルシューティング
* カルチャーへの理解
* インシデント管理
#### SREチーム

1. オールSREのアプローチ
    + Oneチーム
2. インフラストラクチャー
    + SREによって信頼性をより反映する
3. ツール
    + 信頼性ツールの活用
4. 製品/アプリケーション
    + 重要なアプリケーションやビジネスユニットへの貢献に集中
5. 統合されたSREチームでの実装
6. SREコンサルティングチームでの実施
    + 組織に良いアドバイスをする


## Optimizing Google Cloud Costs
* コスト管理
* 予算管理
* アラート設定
* 割引
    + 分析機能
* BigQuery
    + コスト割り当てによる制限
* Cloud Functions
* IPアドレス
* ストレージ
* ネットワーク

## Using Ruby on Rails with Cloud SQL for PostgreSQL on Cloud Run
    RailsサイトはCloud Runから提供され、複数のバックサービスを使用して異なるデータタイプ（リレーショナルデータベース情報、メディアアセット、構成シークレット、およびコンテナイメージ）を保存します。バックエンド サービスは、構築および移行タスクの一部として Cloud Build によって更新されます。
### 環境を整える
### バックアップサービスの準備
#### Cloud SQL for PostgreSQLインスタンスのセットアップ
#### クラウドストレージのバケットをセットアップする
### シークレットマネージャーにシークレットバリューを保存
#### 暗号化された認証情報ファイルを作成し、キーをSecret Managerのシークレットとして保存します。
#### Railsアプリを本番環境のデータベースとストレージに接続
#### Cloud BuildからCloud SQLへのアクセス権付与
### アプリをCloud Runにデプロイする
### コードを理解する
#### データベース接続
    アプリがCloud Run（フルマネージド）上で実行される場合、Cloud Run環境が提供するソケットを介してPostgreSQLインスタンスに接続されます。アプリがローカルマシン上で実行される場合、Cloud SQL Auth proxyを介してPostgreSQLインスタンスに接続します。
#### ユーザーがアップロードしたメディアをクラウドに保存
#### Cloud Buildによる自動化




GSP943
Overview
Setup and Requirements
Task 1. Preparing Your Environment
Task 2. Preparing the Backing Services
Task 3. Store secret values in Secret Manager
Task 4. Deploying the app to Cloud Run
Task 5. Understanding the Code
Congratulations!
GSP943
Google Cloud self-paced labs logo

Overview
In this Qwiklab, you will learn how to deploy a sample Rails application to Cloud Run and how to integrate managed databases, object storage, encrypted secrets, and build pipelines with serverless compute.

Google Cloud SQL for PostgreSQL is a fully-managed database service that makes it easy to set up, maintain, manage, and administer your PostgreSQL relational databases on Google Cloud.

Cloud Run is a managed compute platform that enables you to run containers that are invocable via requests or events. Cloud Run is serverless: it abstracts away all infrastructure management, so you can focus on what matters most — building great applications.

Deploying Rails applications involves integrating multiple services together to form a cohesive project. Here's a visual example of the application you will deploy for this lab:

Architecture of Ruby on Rails with Cloud SQL for PostgreSQL on Cloud Run

The Rails site is served from Cloud Run, which uses multiple backing services to store different data types (relational database information, media assets, configuration secrets, and container images). The backend services are updated by Cloud Build as part of a build and migrate task.

What you'll learn
How to create and connect a Cloud SQL database to Active Record
How to create and use Secret Manager to store and access a Rails master key securely
How to host user-uploaded media and files on Cloud Storage from Active Storage
How to set up a Rails app with PostgreSQL
How to use Cloud Build to automate build and database migrations
How to deploy a Rails app to Cloud Run
What you'll need
A Browser, such Chrome or Firefox
Familiarity with standard Linux text editors such as Vim, Emacs or Nano
Familiarity using Ruby
Setup and Requirements
Qwiklabs setup
Before you click the Start Lab button
Read these instructions. Labs are timed and you cannot pause them. The timer, which starts when you click Start Lab, shows how long Google Cloud resources will be made available to you.

This hands-on lab lets you do the lab activities yourself in a real cloud environment, not in a simulation or demo environment. It does so by giving you new, temporary credentials that you use to sign in and access Google Cloud for the duration of the lab.

To complete this lab, you need:

Access to a standard internet browser (Chrome browser recommended).
Note: Use an Incognito or private browser window to run this lab. This prevents any conflicts between your personal account and the Student account, which may cause extra charges incurred to your personal account.
Time to complete the lab---remember, once you start, you cannot pause a lab.
Note: If you already have your own personal Google Cloud account or project, do not use it for this lab to avoid extra charges to your account.
Cloud Console
How to start your lab and sign in to the Google Cloud Console
Click the Start Lab button. If you need to pay for the lab, a pop-up opens for you to select your payment method. On the left is the Lab Details panel with the following:

The Open Google Console button
Time remaining
The temporary credentials that you must use for this lab
Other information, if needed, to step through this lab
Click Open Google Console. The lab spins up resources, and then opens another tab that shows the Sign in page.

Tip: Arrange the tabs in separate windows, side-by-side.

Note: If you see the Choose an account dialog, click Use Another Account.
If necessary, copy the Username from the Lab Details panel and paste it into the Sign in dialog. Click Next.

Copy the Password from the Lab Details panel and paste it into the Welcome dialog. Click Next.

Important: You must use the credentials from the left panel. Do not use your Google Cloud Skills Boost credentials.
Note: Using your own Google Cloud account for this lab may incur extra charges.
Click through the subsequent pages:

Accept the terms and conditions.
Do not add recovery options or two-factor authentication (because this is a temporary account).
Do not sign up for free trials.
After a few moments, the Cloud Console opens in this tab.

Note: You can view the menu with a list of Google Cloud Products and Services by clicking the Navigation menu at the top-left. Navigation menu icon
Cloud Shell
Activate Cloud Shell
Cloud Shell is a virtual machine that is loaded with development tools. It offers a persistent 5GB home directory and runs on the Google Cloud. Cloud Shell provides command-line access to your Google Cloud resources.

Click Activate Cloud Shell Activate Cloud Shell icon at the top of the Google Cloud console.

Click Continue.

It takes a few moments to provision and connect to the environment. When you are connected, you are already authenticated, and the project is set to your PROJECT_ID. The output contains a line that declares the PROJECT_ID for this session:

Your Cloud Platform project in this session is set to YOUR_PROJECT_ID
gcloud is the command-line tool for Google Cloud. It comes pre-installed on Cloud Shell and supports tab-completion.

(Optional) You can list the active account name with this command:

gcloud auth list
コピーしました
Output:

ACTIVE: *
ACCOUNT: student-01-xxxxxxxxxxxx@qwiklabs.net
To set the active account, run:
    $ gcloud config set account `ACCOUNT`
(Optional) You can list the project ID with this command:

gcloud config list project
コピーしました
Output:

[core]
project = <project_ID>
Example output:

[core]
project = qwiklabs-gcp-44776a13dea667a6
Note: For full documentation of gcloud, in Google Cloud, refer to the gcloud CLI overview guide.
Task 1. Preparing Your Environment
Cloning the Rails app
The code for the Rails sample app is in the GoogleCloudPlatform/ruby-docs-samples repository on GitHub.

Clone the repository:

git clone https://github.com/GoogleCloudPlatform/ruby-docs-samples.git
コピーしました
Go to the directory that contains the sample code and run the following commands to ensure the application is properly set up with the required gems and dependencies:

cd ruby-docs-samples/run/rails
bundle install
コピーしました
Task 2. Preparing the Backing Services
This labs uses a number of Google Cloud services to provide the database, media storage, and secret storage that support the deployed Rails project. These services are deployed in a specific region. For efficiency between services, it is best that all services are deployed in the same region.

Note: If running this in a personal project, you would need to ensure the Cloud Run, Cloud SQL, Cloud Build, Secret Manager, and Compute Engine APIs are enabled and that Ruby >= 2.7 with Rails >= 6.0 is installed. Your Qwiklabs project automatically enables the necessary APIs and your Cloud Shell comes pre-installed with Ruby on Rails.
Set up a Cloud SQL for PostgreSQL instance
Rails supports multiple relational databases, including several offered by Cloud SQL. This lab uses PostgreSQL, an open source database commonly used by Rails apps.

The following sections describe the creation of a PostgreSQL instance, database, and database user for your Rails app.

Define re-usable environment variables for your instance name, region, and database name:

INSTANCE_NAME=postgres-instance
DATABASE_NAME=mydatabase
REGION=us-central1
コピーしました
Create your PostgreSQL Instance:

gcloud sql instances create $INSTANCE_NAME \
  --database-version POSTGRES_12 \
  --tier db-g1-small \
  --region $REGION
コピーしました
Create the database within the recently created instance:

gcloud sql databases create $DATABASE_NAME \
  --instance $INSTANCE_NAME
コピーしました
Generate a random password for the database user, and write it to a file called dbpassword:

cat /dev/urandom | LC_ALL=C tr -dc '[:alpha:]'| fold -w 50 | head -n1 > dbpassword
コピーしました
Create the user (named qwiklabs_user) within the recently created instance and set its password to be the content of dbpassword:

 gcloud sql users create qwiklabs_user \
   --instance=$INSTANCE_NAME --password=$(cat dbpassword)
コピーしました
Click Check my progress to verify the objective.
Set up a Cloud SQL for PostgreSQL instance

Set up a Cloud Storage bucket
You can host Rails static assets and user-uploaded media in highly available object storage using Cloud Storage.

Assign a Bucket Name and create a Cloud Storage bucket:

BUCKET_NAME=$DEVSHELL_PROJECT_ID-ruby
gsutil mb -l us-central1 gs://$BUCKET_NAME
コピーしました
After creating a bucket, to make the uploaded images public, change the permissions of image objects to be readable by everyone.

gsutil iam ch allUsers:objectViewer gs://$BUCKET_NAME
コピーしました
Click Check my progress to verify the objective.
Set up a Cloud Storage bucket

Task 3. Store secret values in Secret Manager
Now that the backing services are configured, Rails needs secure information, such as passwords, to access these services. Instead of putting these values directly into the Rails source code, this lab uses Rails Credentials and Secret Manager to store this information securely.

Create encrypted credentials file and store key as Secret Manager secret
Rails stores secrets in an encrypted file called config/credentials.yml.enc. The file can be decrypted with the local config/master.key or the environment variable ENV[“RAILS_MASTER_KEY”]. In the credentials file, you can store the Cloud SQL Instance database password and other access keys for external APIs.

You can store this key securely in Secret Manager. Then, you can grant Cloud Run and Cloud Build access to the key by granting access to their respective service accounts. Service accounts are identified by an email address that contains the project number.

Generate the config/credentials.yml.enc file with the following command:

EDITOR="nano" bin/rails credentials:edit
コピーしました
The command will create a config/master.key if no master key is defined, and create a config/credentials.yml.enc file if the file does not exist. This will open a temporary file in the assigned $EDITOR with the decrypted contents for the secrets to be added.

Copy and paste the necessary fields for your database at the end of the credentials file:

gcp:
  db_password: REPLACE_WITH_DB_PASSWORD
コピーしました
Do not close the editor yet. You will get the db_password value next.

Open a new tab in your Cloud Shell by pressing the + button.

Run this command to review the password saved in your dbpassword file:

cat ~/ruby-docs-samples/run/rails/dbpassword
コピーしました
Copy your output from the previous command.

Return to your first Cloud Shell tab with your credentials file open in an editor.

Replace the REPLACE_WITH_DB_PASSWORD value with the password you copied.

Your credentials file should look similar to this (DO NOT COPY):

# aws:
#   access_key_id: 123
#   secret_access_key: 345
# Used as the base secret for all MessageVerifiers in Rails, including the one protecting cookies.
secret_key_base: af9a4995ff8495e9a6bd5a035e674d1dac0fae06ac97577293fcee14147c07ba70a48db9497d3249af0896e1897ae1e12bc5b546b7c5139c333abde15ff43d20
gcp:
  db_password: EmbfjkFhaExrXlouRIZwjZBpAqzZlaatwqaMPPnpzkppVsXmrp
Note: If your editor closed, rerun EDITOR="nano" bin/rails credentials:edit to edit your credentials file again. This command should be run in the ~/ruby-docs-samples/run/rails directory.
Secrets can be accessed with Rails.application.credentials. For example, Rails.application.credentials.secret_key_base should return the application's secret key base and Rails.application.credentials.gcp[:db_passsword] should return your database password.

Press control + x and then y to save and exit your credentials.
The config/credentials/yml.enc is stored encrypted, but config/master.key can be stored in Secret Manager.

Create a new secret with the value of the config/master.key:

gcloud secrets create rails_secret --data-file config/master.key
コピーしました
To confirm the creation of the secret, check it:

gcloud secrets describe rails_secret
gcloud secrets versions access latest --secret rails_secret
コピーしました
Get the value of the project number:

PROJECT_NUMBER=$(gcloud projects describe $DEVSHELL_PROJECT_ID --format='value(projectNumber)')
コピーしました
Grant access to the secret to the Cloud Run service account:

gcloud secrets add-iam-policy-binding rails_secret \
  --member serviceAccount:$PROJECT_NUMBER-compute@developer.gserviceaccount.com \
  --role roles/secretmanager.secretAccessor
コピーしました
Grant access to the secret to the Cloud Build service account:

 gcloud secrets add-iam-policy-binding rails_secret \
   --member serviceAccount:$PROJECT_NUMBER@cloudbuild.gserviceaccount.com \
   --role roles/secretmanager.secretAccessor
コピーしました
Connect Rails app to production database and storage
This lab uses a PostgreSQL instance as the production database and Cloud Storage as the storage backend. For Rails to connect to the newly created database and storage bucket, you need to specify all the information needed to access them in the .env file.

Our .env file contains the configuration for the application environment variables. The application will read this file using the dotenv gem. Since the secrets are stored in credentials.yml.enc and Secret Manger, the .env doesn’t have to be encrypted because it doesn’t hold any sensitive credentials.

Take a look at your .env file:

cat .env
コピーしました
You'll notice there are key value pairs which you can define to set up your connection.

To configure the Rails app to connect with the database and storage bucket, run this command:

cat << EOF > .env
PRODUCTION_DB_NAME: $DATABASE_NAME
PRODUCTION_DB_USERNAME: qwiklabs_user
CLOUD_SQL_CONNECTION_NAME: $DEVSHELL_PROJECT_ID:$REGION:$INSTANCE_NAME
GOOGLE_PROJECT_ID: $DEVSHELL_PROJECT_ID
STORAGE_BUCKET_NAME: $BUCKET_NAME
EOF
コピーしました
You filled out your .env file with the variables you used to store the values for your database, project, region, instance, and bucket earlier in the lab.

Grant Cloud Build access to Cloud SQL
In order for Cloud Build to apply the database migrations, you need to grant permissions for Cloud Build to access Cloud SQL:

gcloud projects add-iam-policy-binding $DEVSHELL_PROJECT_ID \
    --member serviceAccount:$PROJECT_NUMBER@cloudbuild.gserviceaccount.com \
    --role roles/cloudsql.client
コピーしました
Click Check my progress to verify the objective.
Create encrypted credentials file and store key as Secret Manager secret

Task 4. Deploying the app to Cloud Run
With the backing services set up, you can now deploy the app as a Cloud Run service.

Change the Ruby base image in the Dockerfile to use the same version of Ruby Cloud Shell uses:

RUBY_VERSION=$(ruby -v | cut -d ' ' -f2 | cut -c1-3)
sed -i "/FROM/c\FROM ruby:$RUBY_VERSION-buster" Dockerfile
コピーしました
These commands store a variable with the major and minor versions of your Ruby version and then reconstruct the line that specifies which image to pull using your Ruby version instead.

Using the supplied cloudbuild.yaml, use Cloud Build to build the image, run the database migrations, and populate the static assets:

APP_NAME=myrubyapp
gcloud builds submit --config cloudbuild.yaml \
    --substitutions _SERVICE_NAME=$APP_NAME,_INSTANCE_NAME=$INSTANCE_NAME,_REGION=$REGION,_SECRET_NAME=rails_secret --timeout=20m
コピーしました
This first build takes a few minutes to complete. If the build timed out, increase the timeout duration by inserting --timeout=2000s into the build command above.

When the build is completed and successful, deploy the Cloud Run service for the first time, setting the service region, base image, and connected Cloud SQL instance:

 gcloud run deploy $APP_NAME \
     --platform managed \
     --region $REGION \
     --image gcr.io/$DEVSHELL_PROJECT_ID/$APP_NAME \
     --add-cloudsql-instances $DEVSHELL_PROJECT_ID:$REGION:$INSTANCE_NAME \
     --allow-unauthenticated \
     --max-instances=3
コピーしました
You should see output that shows the deployment succeeded, with a service URL:

 Service [rubyapp] revision [rubyapp-00001-tug] has been deployed
  and is serving 100 percent of traffic at https://rubyapp-HASH-uc.a.run.app
To see the deployed service, go to the service URL.
Web page showing empty cat photo album

If the service URL shows Cat Photo Album, you're on the homepage of the app.

Try to upload a new photo.
If the photo successfully uploads, the Rails application has been successfully deployed.

Web page showing cat photo album with one cat image

Click Check my progress to verify the objective.
Deploy the app to Cloud Run.

Task 5. Understanding the Code
The Rails sample app was created using standard Rails commands. The following commands create the cat_album app and use the scaffold command to generate a model, controller, and views for the Photo resource:

rails new cat_album
rails generate scaffold Photo caption:text
Database Connection
The config/database.yml file contains the configuration needed to access your databases in different environments (development, test, production).

For example, the production database is configured to run in Cloud SQL for PostgreSQL. The database name and username are set through environment variables in the .env file, while the database password is stored inside the config/credentials.yml.enc file, which requires the RAILS_MASTER_KEY to decrypt.

When the app runs on Cloud Run (fully managed), it connects to the PostgreSQL instance via a socket provided by the Cloud Run environment. When the app runs on your local machine, it connects to the PostgreSQL instance via Cloud SQL Auth proxy.

run/rails/config/database.yml:

production:
  <<: *default
  database: <%= ENV["PRODUCTION_DB_NAME"] %>
  username: <%= ENV["PRODUCTION_DB_USERNAME"] %>
  password: <%= Rails.application.credentials.gcp[:db_password] %>
  host: "<%= ENV.fetch("DB_SOCKET_DIR") { '/cloudsql' } %>/<%= ENV["CLOUD_SQL_CONNECTION_NAME"] %>"
Cloud-stored user uploaded media
Rails uses Active Storage to upload files to cloud storage providers.The config/storage.yml and config/environments/production.rb files specify Google Cloud Storage as the service provider in the production environment.

run/rails/config/storage.yml:

google:
  service: GCS
  project: <%= ENV["GOOGLE_PROJECT_ID"] %>
  bucket: <%= ENV["STORAGE_BUCKET_NAME"] %>
run/rails/config/environments/production.rb:

# Store uploaded files on the local file system (see config/storage.yml for options).
config.active_storage.service = :google
Automation with Cloud Build
The cloudbuild.yaml file performs not only the typical image build steps (creating the container image and pushing that to the container registry), but also the Rails database migrations. These require access to the database, which is performed by using the app-engine-exec-wrapper, a helper for Cloud SQL Auth proxy.

run/rails/cloudbuild.yaml:

steps:
  - id: "build image"
    name: "gcr.io/cloud-builders/docker"
    entrypoint: 'bash'
    args: ["-c", "docker build --build-arg MASTER_KEY=$$RAILS_KEY -t gcr.io/${PROJECT_ID}/${_SERVICE_NAME} . "]
    secretEnv: ["RAILS_KEY"]
  - id: "push image"
    name: "gcr.io/cloud-builders/docker"
    args: ["push", "gcr.io/${PROJECT_ID}/${_SERVICE_NAME}"]
  - id: "apply migrations"
    name: "gcr.io/google-appengine/exec-wrapper"
    entrypoint: "bash"
    args:
      [
        "-c",
        "/buildstep/execute.sh -i gcr.io/$PROJECT_ID/${_SERVICE_NAME} -s ${PROJECT_ID}:${_REGION}:${_INSTANCE_NAME} -e RAILS_MASTER_KEY=$$RAILS_KEY -- bundle exec rails db:migrate"
      ]
    secretEnv: ["RAILS_KEY"]
substitutions:
  _REGION: us-central1
  _SERVICE_NAME: rails-cat-album
  _INSTANCE_NAME: cat-album
  _SECRET_NAME: rails-master-key
availableSecrets:
  secretManager:
  - versionName: projects/${PROJECT_ID}/secrets/${_SECRET_NAME}/versions/latest
    env: RAILS_KEY
images:
  - "gcr.io/${PROJECT_ID}/${_SERVICE_NAME}"
Substitution variables are used in this configuration. Changing the values in the file directly means the --substitutions flag can be dropped at migration time.

In this configuration, only existing migrations in the db/migrate directory are applied. To create migration files, see Active Record Migrations.

To build the image and apply migrations, the Cloud Build configuration needs access to the RAILS_MASTER_KEY secret from Secret Manager. The availableSecrets field sets the secret version and environment variables to use for the secret. The master key secret is passed in as an argument in the build image step and then gets set to be the RAILS_MASTER_KEY in the Dockerfile when building the image.

run/rails/Dockerfile:

ARG MASTER_KEY
ENV RAILS_MASTER_KEY=${MASTER_KEY}
To extend the Cloud Build configuration to include the deployment in the one configuration without having to run two commands, see Continuous deployment from git using Cloud Build. This requires IAM changes, as described.

Congratulations!
You learned how to use Cloud SQL for PostgreSQL using Ruby on Rails and then deploy it on the Cloud Run environment.

Finish Your Quest
web application quest badge cloudsql quest badge

A Quest is a series of related labs that form a learning path. This self-paced lab is part of the Qwiklabs Quests Website and Web Application and Cloud SQL. Completing this Quest earns you the badge above to recognize your achievement. You can make your badge public and link to them in your online resume or social media account.

Enroll in Website and Web Application or Cloud SQL and get immediate completion credit if you've taken this lab. See other available Qwiklabs Quests.

Next Steps / Learn More
Continue your learning with another lab:

Deploy Refinery CMS to App Engine Flexible Environment
Ruby on Google Cloud
Google Cloud SQL for PostgreSQL
Google Cloud Ruby Gem
Google Cloud training and certification
...helps you make the most of Google Cloud technologies. Our classes include technical skills and best practices to help you get up to speed quickly and continue your learning journey. We offer fundamental to advanced level training, with on-demand, live, and virtual options to suit your busy schedule. Certifications help you validate and prove your skill and expertise in Google Cloud technologies.

Manual Last Updated March 17, 2022
Lab Last Tested March 17, 2022
Copyright 2022 Google LLC All rights reserved. Google and the Google logo are trademarks of Google LLC. All other company and product names may be trademarks of the respective companies with which they are associated.

その他のコメント

## Deploy Your Website on Cloud Run
ウェブサイトを Cloud Run にデプロイする
1時間
無料
GSP659
Google Cloud セルフペース ラボ

概要
ウェブサイトの運用は容易ではありません。VM、クラスタ、Pod、Service などを作成、管理するためのオーバーヘッドが発生するからです。大規模な多層アプリケーションであれば仕方ありませんが、ウェブサイトをデプロイして公開するだけの場合、こうしたオーバーヘッドは大きな負担です。

Google Cloud 上の Cloud Run という Google の KNative フレームワークの実装を使用してウェブサイトを管理、デプロイすると、VM や純粋な Kubernetes ベースのデプロイに伴うインフラストラクチャのオーバーヘッドを回避できます。管理が簡素化されるだけでなく、ウェブサイトでリクエストを受信していないときは「ゼロにスケール」できます。

コンテナに「サーバーレス」の開発環境をもたらす Cloud Run は、独自の Google Kubernetes Engine（GKE）クラスタ上で実行することも、Cloud Run が提供するフルマネージドの PaaS ソリューションで実行することもできます。このラボでは後者のシナリオを適用します。

ここでは、一般的なクラウド開発プロセスの手順に沿って以下の順序で演習を進めます。

アプリケーションから Docker コンテナを作成する

コンテナを Cloud Run にデプロイする

ウェブサイトに変更を加える

ダウンタイムなしで新しいバージョンをロールアウトする

アーキテクチャの図
以下の図で、Cloud Run にデプロイしてホストする際のフローを確認できます。

まず、Cloud Shell で Cloud Build をトリガーしてイメージを作成します。次に、Cloud Shell からコマンドを実行して、そのイメージを Cloud Run にデプロイします。

db5f05c090d5ebcb.png

学習内容
Cloud Build を使用して Docker イメージをビルドして gcr.io にアップロードする方法

Docker イメージを Cloud Run にデプロイする方法

Cloud Run デプロイメントを管理する方法

Cloud Run にアプリケーションのエンドポイントを設定する方法

環境設定
[ラボを開始] ボタンをクリックする前に
こちらの手順をお読みください。ラボの時間は記録されており、一時停止することはできません。[ラボを開始] をクリックするとスタートするタイマーは、Google Cloud のリソースを利用できる時間を示しています。

この Qwiklabs ハンズオンラボでは、シミュレーションやデモ環境ではなく、実際のクラウド環境を使ってご自身でラボのアクティビティを行うことができます。そのため、ラボの受講中に Google Cloud にログインおよびアクセスするための、新しい一時的な認証情報が提供されます。

必要なもの
このラボを完了するためには、下記が必要です。

標準的なインターネット ブラウザ（Chrome を推奨）
ラボを完了するために十分な時間
注: すでに個人の Google Cloud アカウントやプロジェクトをお持ちの場合でも、ラボでは使用しないでください。

注: Chrome OS デバイスを使用している場合は、シークレット ウィンドウを開いてこのラボを実行してください。

ラボを開始して Console にログインする方法
[ラボを開始] ボタンをクリックします。ラボの料金をお支払いいただく必要がある場合は、表示されるポップアップでお支払い方法を選択してください。 左側のパネルには、このラボで使用する必要がある一時的な認証情報が表示されます。

Google Console を開く

ユーザー名をコピーし、[Google Console を開く] をクリックします。 ラボでリソースが起動し、別のタブで [アカウントの選択] ページが表示されます。

ヒント: タブをそれぞれ別のウィンドウで開き、並べて表示しておきましょう。

[アカウントの選択] ページで [別のアカウントを使用] をクリックします。

アカウントを選択

[ログイン] ページが開きます。[接続の詳細] パネルでコピーしたユーザー名を貼り付けます。パスワードもコピーして貼り付けます。

重要: 認証情報は [接続の詳細] パネルに表示されたものを使用してください。ご自身の Qwiklabs 認証情報は使用しないでください。請求が発生する事態を避けるため、GCP アカウントをお持ちの場合でもそのアカウントはラボで使用しないでください。

以降のページでは次の点にご注意ください。

利用規約に同意してください。
復元オプションや 2 要素認証プロセスは設定しないでください（一時的なアカウントであるため）。
無料トライアルには登録しないでください。
しばらくすると、このタブで GCP Console が開きます。

注: 左上の [Google Cloud Platform] の横にあるナビゲーション メニューをクリックすると、GCP のプロダクトやサービスのリストが含まれるメニューが表示されます。 Cloud Console メニュー
Google Cloud Shell の有効化
Google Cloud Shell は、デベロッパー ツールと一緒に読み込まれる仮想マシンです。5 GB の永続ホーム ディレクトリが用意されており、Google Cloud で稼働します。Google Cloud Shell では、コマンドラインで GCP リソースにアクセスできます。

GCP Console の右上のツールバーにある [Cloud Shell をアクティブにする] ボタンをクリックします。

Cloud Shell アイコン

[続行] をクリックします。

cloudshell_continue

環境のプロビジョニングと接続には少し時間がかかります。接続すると、すでに認証されており、プロジェクトは PROJECT_ID に設定されています。例えば:

Cloud Shell 端末

gcloud は Google Cloud Platform のコマンドライン ツールです。このツールは、Cloud Shell にプリインストールされており、タブ補完がサポートされています。

次のコマンドを使用すると、有効なアカウント名を一覧表示できます。

gcloud auth list
出力:

ACTIVE: *
ACCOUNT: student-01-xxxxxxxxxxxx@qwiklabs.net
To set the active account, run:
    $ gcloud config set account `ACCOUNT`
	
次のコマンドを使用すると、プロジェクト ID を一覧表示できます。

gcloud config list project
	
出力:

[core]
project = <project_ID>
	
出力例:

[core]
project = qwiklabs-gcp-44776a13dea667a6
	
gcloud について詳しくは、gcloud の概要をご確認ください。
ソース リポジトリのクローンを作成する
デプロイするウェブサイトはすでに存在するため、ソースのクローンを作成するだけで、後は Docker イメージの作成と Cloud Run へのデプロイに集中できます。

以下のコマンドを実行して Cloud Shell インスタンス内に git リポジトリのクローンを作成し、適切なディレクトリに移動します。NodeJS 依存関係もインストールして、アプリケーションをデプロイ前にテストできるようにします。

git clone https://github.com/googlecodelabs/monolith-to-microservices.git
cd ~/monolith-to-microservices
./setup.sh
このコマンドの実行が完了するまでには数分かかります。完了すると、成功のメッセージが表示されます。

アプリケーションをテストするために、次のコマンドを実行してウェブサーバーを起動します。

cd ~/monolith-to-microservices/monolith
npm start
出力:

Monolith listening on port 8080!
ウェブでプレビュー アイコンをクリックし、[ポート 8080 でプレビュー] を選択してアプリケーションをプレビューします。

CloudShell_web_preview.png

新しいウィンドウが開き、動作中の Fancy Store ウェブページが表示されます。

hostwebsite-welc-fancystore.png

ウェブサイトを確認したら、このウィンドウを閉じます。Cloud Shell で Ctrl+C キーを押して、ウェブサーバー プロセスを停止します。

Cloud Build を使用して Docker コンテナを作成する
ソースファイルを使用できる状態になったので、次はアプリケーションを Docker 化します。

通常、Docker コンテナを作成するには 2 ステップのアプローチを取る必要があります。具体的には、Docker コンテナをビルドするステップと、ビルドしたコンテナをレジストリに push してそのイメージを保管し、GKE がそこからイメージを pull できるようにするステップです。作業を楽にするために、Cloud Build を使用して 1 つのコマンドで Docker コンテナをビルドし、イメージを Container Registry に保存します。手動で Docker ファイルを作成して push するプロセスを確認するには、こちらをご覧ください。

Google Cloud Build がディレクトリにあるファイルを圧縮して Google Cloud Storage バケットに移動します。次に、ビルドプロセスでそのバケットからすべてのファイルを取得し、同じディレクトリにある Dockerfile を使用して Docker ビルドプロセスを実行します。--tag フラグで Docker イメージのホストとして gcr.io を指定したため、ビルドされた Docker イメージは Container Registry に push されます。

まず、次のコマンドを実行して Cloud Build API を有効にします。

gcloud services enable cloudbuild.googleapis.com
API が有効になったら、次のコマンドを実行してビルドプロセスを開始します。

gcloud builds submit --tag gcr.io/${GOOGLE_CLOUD_PROJECT}/monolith:1.0.0 .
このプロセスが完了するまでには数分かかります。完了すると、ターミナルに次のような結果が出力されます。

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ID                                    CREATE_TIME                DURATION  SOURCE                                                                                  IMAGES                              STATUS
1ae295d9-63cb-482c-959b-bc52e9644d53  2019-08-29T01:56:35+00:00  33S       gs://<PROJECT_ID>_cloudbuild/source/1567043793.94-abfd382011724422bf49af1558b894aa.tgz  gcr.io/<PROJECT_ID>/monolith:1.0.0  SUCCESS
ビルドの履歴を表示する場合、またはプロセスをリアルタイムで観察する場合は、Console のナビゲーション メニューで [Cloud Build] > [履歴] をクリックします。すべてのビルドのリストが表示されます。リストには、作成したばかりのビルドが 1 つだけ示されているはずです。

4c753ede203255f6.png

ビルド ID をクリックすると、そのビルドのすべての詳細が表示されます。詳細にはログ出力も含まれます。

[ビルドの詳細] ページで [実行の詳細] タブをクリックし、作成したコンテナ イメージのリンクをクリックすると、そのイメージが表示されます。

Build_details.png

[進行状況を確認] をクリックして、目標に沿って進んでいることを確認します。
Google Cloud Build を使用して Docker コンテナを作成する


コンテナを Cloud Run にデプロイする
ウェブサイトをコンテナ化して、そのコンテナを Container Registry に push したので、次はコンテナを Cloud Run にデプロイしましょう。

Cloud Run にデプロイするには次の 2 つの方法があります。

マネージド Cloud Run: すべてのコンテナ ライフサイクルが Cloud Run プロダクト自体によって管理される、Platform-as-a-Service（PaaS）モデルです。このラボでは、この方法を使用します。

Cloud Run on GKE: 制御が強化された Cloud Run を使用して、GKE で作成した独自のクラスタと Pod を導入できます。詳細については、こちらをご覧ください。

コマンドライン
前の手順でビルドしたイメージをデプロイするために、--platform managed を指定してマネージド バージョンの Cloud Run を使用します。

まず、Cloud Run API を有効にする必要があります。次のコマンドを実行して有効にします。

gcloud services enable run.googleapis.com
次のコマンドを実行して、アプリケーションをデプロイします。

gcloud run deploy --image=gcr.io/${GOOGLE_CLOUD_PROJECT}/monolith:1.0.0 --platform managed --max-instances=1
実行するリージョンを指定します。最も近いリージョンの番号を入力します。

d52d9419c5166674.png

Enter キーを押して、提案されているデフォルトのサービス名（「monolith」）を受け入れます。

このラボでは、認証されていないリクエストをアプリケーションで許可します。プロンプトが表示されたら、「Y」を入力します。

3a57b32f133dad61.png

[進行状況を確認] をクリックして、目標に沿って進んでいることを確認します。
コンテナを Cloud Run にデプロイする

デプロイメントを確認する
次のコマンドを実行して、デプロイメントが正常に作成されたことを確認します。

gcloud run services list
Pod のステータスが [実行中] になるまで少し時間がかかることがあります。

「1」を入力して最初のオプション [1] Cloud Run（フルマネージド）を選択します。

出力:


SERVICE   REGION    URL  LAST DEPLOYED BY          LAST DEPLOYED AT
✔  monolith  us-east1 <your url>  <your email>  2019-09-16T21:07:38.267Z

この出力で、デプロイメント、デプロイしたユーザー（ユーザーのメールアドレス）、アプリにアクセスする際に使用する URL を確認できます。これらが示されていれば、デプロイメントは正常に作成されています。

サービスのリストに示されている URL をクリックします。前にローカルでプレビューしたのと同じウェブサイトが表示されます。

ヒント: Cloud Run のデプロイメントを確認するには、Console のナビゲーション メニューで [Cloud Run] に移動するという方法もあります。

同時実行の値を小さくした新しいリビジョンを作成する
アプリケーションを再度デプロイします。ただし、今回はパラメータのうちの 1 つを調整します。

デフォルトでは、Cloud Run アプリケーションの同時実行の値は 80 に設定されます。つまり、各コンテナ インスタンスは一度に最大 80 件のリクエストを処理します。この設定は、1 つのインスタンスが一度に 1 件のリクエストを処理する Functions-as-a-Service モデルとはかなり異なります。

同時実行の値を（テスト用に）1 に設定して同じコンテナ イメージを再デプロイし、どうなるかを確認します。

gcloud run deploy --image=gcr.io/${GOOGLE_CLOUD_PROJECT}/monolith:1.0.0 --platform managed --concurrency 1 --max-instances=1
以降の質問には最初にデプロイしたときと同じように答えます。コマンドが正常に実行されたら、Console で結果を確認します。

詳細を表示するために、ナビゲーション メニューで [Cloud Run]、[monolith] サービスの順にクリックします。

7d1eed2e4728a4f2.png

[サービスの詳細] ページで [リビジョン] タブをクリックします。2 つのリビジョンが作成されていることを確認します。

右側に最新のデプロイメントの詳細が表示されます。

monolith-revisions.png

同時実行の値が「1」に減らされていることがわかります。

monolith-details.png

テストにはこの構成で十分ですが、本番環境でのほとんどのシナリオでは、コンテナで複数の同時リクエストをサポートすることになります。

[進行状況を確認] をクリックして、目標に沿って進んでいることを確認します。
同時実行の値を小さくした新しいリビジョンを作成する

同時実行の値を元に戻します。ただし、再デプロイは行いません。

同時実行の値をデフォルトの「80」に戻すか、「0」に設定します。後者の場合、同時実行の制限がすべて削除され、デフォルトの最大値（同じく 80）に設定されます。

Cloud Shell で次のコマンドを実行して、現在のリビジョンを更新します。

gcloud run deploy --image=gcr.io/${GOOGLE_CLOUD_PROJECT}/monolith:1.0.0 --platform managed --concurrency 80 --max-instances=1
以降の質問には前と同じように答えます。

別のリビジョンが作成されたこと、トラフィックがリダイレクトされるようになったこと、同時実行数が最大 80 に戻されたことを確認します。

[リビジョン] タブを表示したままにして、このタブに戻って最新の情報を確認します。

ウェブサイトに変更を加える
シナリオ: マーケティング チームから、サイトのホームページを変更するよう依頼されました。マーケティング チームは、会社の概要と販売している製品のより詳しい情報を追加する必要があると考えています。

タスク: マーケティング チームからの依頼に応じたテキストをホームページに追加します。デベロッパーの 1 人がすでに index.js.new というファイルで変更内容を作成したようです。このファイルを index.js にコピーするだけで、その変更内容をホームページに反映できます。以下の手順に従って、適切な変更を行ってください。

以下のコマンドを実行して、更新されたファイルを正しい名前のファイルにコピーし、その内容を出力して変更を確認します。

cd ~/monolith-to-microservices/react-app/src/pages/Home
mv index.js.new index.js
cat ~/monolith-to-microservices/react-app/src/pages/Home/index.js
変更後のコードは次のようになります。

/*
Copyright 2019 Google LLC
Apache ライセンス バージョン 2.0（「ライセンス」）による使用許諾。
ライセンスに準拠している場合を除き、このファイルは使用できません。
ライセンスのコピーは次の URL から取得できます。
    https://www.apache.org/licenses/LICENSE-2.0
適用される法律で定められている場合、または書面での合意がある場合を除き、
ライセンスに従って配布されるソフトウェアは、明示か黙示かを問わず、
いかなる保証も条件も伴わない「現状有姿」で提供されます。ライセンスに従って権限と制限事項を規定する具体的な文言については、
「ライセンス」を参照してください。*/
import React from "react";
import { makeStyles } from "@material-ui/core/styles";
import Paper from "@material-ui/core/Paper";
import Typography from "@material-ui/core/Typography";
const useStyles = makeStyles(theme => ({
  root: {
    flexGrow: 1
  },
  paper: {
    width: "800px",
    margin: "0 auto",
    padding: theme.spacing(3, 2)
  }
}));
export default function Home() {
  const classes = useStyles();
  return (
    <div className={classes.root}>
      <Paper className={classes.paper}>
        <Typography variant="h5">
          Fancy Fashion &amp; Style Online
        </Typography>
        <br />
        <Typography variant="body1">
          Tired of mainstream fashion ideas, popular trends and societal norms?
          This line of lifestyle products will help you catch up with the Fancy trend and express your personal style.
          Start shopping Fancy items now!
        </Typography>
      </Paper>
    </div>
  );
}
これで React コンポーネントは更新されましたが、React アプリをビルドして静的ファイルを生成する必要があります。

次のコマンドを実行して React アプリをビルドし、monolith の公開ディレクトリにコピーします。

cd ~/monolith-to-microservices/react-app
npm run build:monolith
コードが更新されたので、Docker コンテナを再ビルドして Container Registry に公開します。前と同じコマンドを使用できますが、今回はバージョン ラベルを更新します。

次のコマンドを実行し、更新後のイメージ バージョン 2.0.0 を指定して新しい Cloud Build をトリガーします。

cd ~/monolith-to-microservices/monolith
省略可

#自由にアプリケーションをテストしてください
npm start
gcloud builds submit --tag gcr.io/${GOOGLE_CLOUD_PROJECT}/monolith:2.0.0 .
次のセクションでは、このイメージを使用してダウンタイムなしでアプリケーションを更新します。

[進行状況を確認] をクリックして、目標に沿って進んでいることを確認します。
ウェブサイトに変更を加える

ダウンタイムなしでウェブサイトを更新する
変更が完了し、マーケティング チームは更新内容に満足しています。次は、ユーザーへのサービスを中断させずにウェブサイトを更新します。

Cloud Run は各デプロイメントを新しいリビジョンとして扱います。つまり、まずリビジョンをオンライン状態にして、トラフィックをそこにリダイレクトします。デフォルトでは、最新のリビジョンにサービスの受信トラフィックの 100% が割り当てられます。「ルート」を使用すると、サービス内でリビジョンごとに異なるパーセンテージのトラフィックを割り当てることができます。

以下の手順に従ってウェブサイトを更新してください。

Cloud Shell で次のコマンドを実行してサービスを再デプロイし、イメージを新しいバージョンに更新します。

gcloud run deploy --image=gcr.io/${GOOGLE_CLOUD_PROJECT}/monolith:2.0.0 --platform managed --max-instances=1
以降の質問には前と同じように答えます。

[進行状況を確認] をクリックして、目標に沿って進んでいることを確認します。
ダウンタイムなしでウェブサイトを更新する

デプロイメントを確認する
次のコマンドを実行して、デプロイメントが更新されたことを確認します。

gcloud run services describe monolith --platform managed
使用しているリージョンの番号を入力します。

出力:

✔ Service monolith in region us-east1
https://monolith-k3wa45c54a-ue.a.run.app
Traffic:
  100%               LATEST (currently monolith-00003-ten)
Last updated on 2020-02-20T20:26:56.049Z by student-03-e32055b0be3a@qwiklabs.net:
  Revision monolith-00003-ten
  Image:             gcr.io/qwiklabs-gcp-03-b1646832ec74/monolith:2.0.0
  Port:              8080
  Memory:            256M
  CPU:               1000m
  Concurrency:       1
  Timeout:           900s
この出力から、サービスが最新バージョンのイメージを使用するようになり、新しいリビジョンにデプロイされたことがわかります。

変更を確認するには、Cloud Run サービスの外部 URL にアクセスしてページを更新します。アプリケーションのタイトルが更新されていれば、正常に変更されています。

次のコマンドを実行してサービスを一覧表示し、IP アドレスを確認します。

gcloud beta run services list
最初のオプション [Cloud Run（フルマネージド）] を選択し、Enter キーを押します。

サービスの URL をクリックします。ウェブサイトに、ホームページ コンポーネントに追加したテキストが表示されるようになりました。

hostwebsite-welc-fancystore-edited.png

クリーンアップ
このラボを終了すると、使用したすべてのリソースが破棄されます。実際の環境でもリソースを削除できるよう、リソースの削除方法を学習しておきましょう。

次のコマンドを実行して Container Registry イメージを削除します。

# monolith のバージョン 1.0.0 のコンテナ イメージを削除します
gcloud container images delete gcr.io/${GOOGLE_CLOUD_PROJECT}/monolith:1.0.0 --quiet
# monolith のバージョン 2.0.0 のコンテナ イメージを削除します
gcloud container images delete gcr.io/${GOOGLE_CLOUD_PROJECT}/monolith:2.0.0 --quiet
次のコマンドを実行して Cloud Build のアーティファクトを Cloud Storage から削除します。

# 次のコマンドはすべてのビルドからソース アーカイブを取得し、Cloud Storage から削除します
# すべてのソースを出力するには、このコマンドを実行します
# gcloud builds list | awk 'NR > 1 {print $4}'
gcloud builds list | awk 'NR > 1 {print $4}' | while read line; do gsutil rm $line; done
最後に、Cloud Run サービスを削除します。

gcloud beta run services delete monolith --platform managed
このラボでサービスを実行するために使用したリージョンを選択して、monolith の削除を確定します。

まとめ
Cloud Run にウェブサイトをデプロイし、スケールダウン、再スケール、更新を行いました。
