# 1.アソシエイト・クラウドエンジニア資格の理解
## GCP 認定資格について
## 学習戦略の立案
## 準備の確認
## 受験

# 2.クラウドソリューションの環境構築
## クラウド プロジェクトとアカウントについて
ここからがこのモジュールの内容です 新しいクラウドプロジェクトと アカウントの設定にはこれらのスキルが必要です これらのタスクを行うには Google Cloud Consoleで プロジェクト、ユーザー、API Stackdriverコンソールなどを使います プロジェクトの作成と ユーザーへの事前定義ロールの割り当ては 基本的な作業なのでまとめて考えましょう

まずシンプルなGoogle Cloudアカウントの 全体構造を確認します この図は組織内のリソース階層の例です プロジェクトを含むすべてのリソースは 組織ノードの下にあります リソースは組織の構造に応じて グループ化して一括管理できます

GCPリソースを使うには プロジェクトに関連付けるか プロジェクト内で有効化します これによりビルドとトラッキングが行われ 権限が付与されます このため アカウントには 最低１つのプロジェクトがあります 基本のプロジェクトは簡単に作れますが ラベルと名前の設定には注意が必要です ２つの黄色い項目は プロジェクトの作成者が指定します プロジェクトIDは設定後に変更できないので 慎重に決めます ３番目のプロジェクト番号は GCPで自動生成されますが 同じく変更不可です

プロジェクトを整理する際に重要な点は すべてが階層化されることです 階層の一番上には組織ノードがあります 他のものはすべて その下にあります フォルダは主に組織で使い 通常は会社と同じ構造にします たとえばマーケティング 財務、人事、ITなどのフォルダを 組織で使うことがあります 新しい組織ノードでは 任意のユーザーとドメインで プロジェクトと請求先アカウントを作れますが 実際に誰がこの操作を行うかを 判断することをおすすめします その後で各ユーザーにロールを割り当てれば 管理しやすさとセキュリティが高まります

GCPの権限は継承されます つまり 子リソースはそれぞれ 親リソースが持つ権限をすべて受け継ぎます 親から継承した権限を 子自身、同一レベル内の別のリソース 階層内の下位リソースが 削除することはできません たとえば親が得たリソース編集用の ユーザーまたはロール権限を 子は削除できません ただし子リソースは 親から継承した権限に別の権限を追加できます これにより リソースを 使用、変更できるユーザーを細かく制御できます

次にGCPリソースのロールを考えます 簡単に言うとロールは権限の集合です ロールは一般に 特定のリソースに対して行えるタスクと そのタスクを行えるユーザーを定義します ロールを使うと リソースに対する権限の 割り当てと管理が簡単になります また 管理者はプロジェクトの各メンバーに 業務に必要な権限だけを付与できます

GCPのユーザーとリソースに付与できる 主なロールは 基本、事前定義、カスタムの３種類です

ここではカスタムロールは扱いません まず３種類の基本ロールを考えましょう オーナー、編集者、閲覧者のロールです

閲覧者はリソースを確認できますが その状態を変更できません 編集者は 閲覧者が行える操作に加えて リソースの状態を変更できます オーナーは 編集者が行える操作に加えて リソースに関するロールと権限を管理できます 複数の人が 機密データを含むプロジェクトで作業する場合 基本ロールではおそらく不十分です 幸いなことにGCP IAMには より細かい種類のロールがあります

権限は 誰がどのリソースに 何を行えるかを定義します 閲覧、編集、管理の権限を 与えることになるので これは権限を おおまかに割り当てる方法と言えるでしょう 一方 GCPの事前定義ロールを使うと 特定の種類のリソースで考えられる 多種多様な選択肢から 誰が何をできるかを限定できます 各サービスではリソースのユーザーに付与できる 一連の権限が事前定義されています 事前定義ロールは 一般的な職務のニーズに応じて 必要な権限をまとめたものです 権限をすべて付与したり 与える権限を個々に選んで 見落としのリスクを冒したりするより 事前定義ロールを割り当てるほうが簡単です

たとえば Compute Engineの一連の事前定義ロールは プロジェクト内、フォルダ内、組織全体の Compute Engineリソースに適用できます 詳しく見てみましょう これは事前定義ロールInstanceAdminが持つ Compute Engine権限の一部です 省略記号は続きがあることを示しています

これらの権限は ロールが VMに対して行える操作を定義します 他の事前定義ロールにも そのロールが一般に行うタスクに応じて 選択された権限のリストがあります 一般的な職務でこれらの事前定義ロールを使うと 管理の時間を節約できます Googleはこれらのロールに 必要な権限を継続的に追加しています すべての権限を全員に与えたほうが 管理が楽だと思いますか？ おそらく楽ですがリスクは大きく 最小権限のセキュリティ原則に反しています 会社の重要なサービスやデータに 偶発的または故意の損害が及ぶかもしれません たとえばCompute Engineインスタンスで 報告データを見る会計士に Compute Engineインスタンスの削除権限は 不要です この権限の付与はセキュリティ面で問題があり 偶発的な削除のリスクを高め 会社が規制に違反することになりかねません

次に組織内のユーザーをG Suite IDによって プロジェクトにリンクする利点を考えます

GCPの新規利用者の多くは GCP Consoleに Gmailアカウントでログインするので 共同作業する場合 同じロールの人をGoogleグループでまとめます この方法は始めるのは簡単ですが チームのIDが一元管理されないのが欠点です たとえば誰かが組織を去った場合に すぐにリソースへのアクセスを削除する 一元管理された方法がありません G Suiteも使用するGCPのお客様は G Suiteユーザーとグループに基づいて GCPポリシーを定義できます こうすれば 誰かが組織を去ったときに 管理者はすぐにGoogle管理コンソールを使い そのアカウントを無効にして グループから削除できます G Suiteを使わないGCPのお客様は Cloud Identity経由で同じ機能を実現できます この場合は管理コンソールで ユーザーとグループを管理できますが 取得したG Suiteプロダクトの 支払いは行いません

またアカウントの新規設定時には 開発、監視、報告用のAPIを プロジェクトで有効にすることが必要です GCPの操作方法は４つありますが ここではAPIだけを考えます CLIは最後のセクションで考えます GCPを構成するサービスで提供される APIを使うと コードからサービスを直接利用できます これらはRESTful APIと呼ばれ Representational State Transfer（REST）の 枠組みに従っています この意味を詳しく知る必要はありませんが 基本的には ブラウザがサーバーと対話するように コードが Googleサービスを利用できるという意味です

GCP ConsoleのAPI Explorerを使うと 使用可能なAPIを インタラクティブに学習できます APIにはパラメータがあり その使用方法の資料も利用できます APIはインタラクティブに使用でき ユーザー認証も行えます メソッドを調べ APIへのリクエストを数回試した後で APIを使うアプリをビルドするとします このとき コーディングを ゼロから始める必要はありません Googleのクライアントライブラリを使い 少ない作業でコードからGCPを呼び出せます

２種類のライブラリがあります Cloudクライアントライブラリは GCPで推奨される最新のAPIライブラリで 各言語独自のスタイルとイディオムを使えます このライブラリでは 新しいサービスや機能を使えないこともあります その場合は対象言語の Google APIクライアントライブラリが有効です ここでは すべてのサービスと機能を使えます

最後は Stackdriverアカウントのプロビジョニングです サーバーとサービスを継続的に稼働するには 性能の安定性をモニタリングする手段が必要です GCPでサーバーとアプリの ロギング/モニタリングを行う方法の一つは Stackdriverです Stackdriverは マルチクラウドの モニタリング/管理用ツールで 指標、ログ、イベントの集約機能と モニタリング、ロギング、診断機能を備え GCP、AWS、オンプレミスを含む 複数のプラットフォームを管理できます デベロッパー、オペレーター セキュリティ担当者は各種のシグナルを観察して 根本原因分析を迅速に行い 平均修復時間を短縮できます

Stackdriverは多くのGCPサービスと プロダクトに統合されています たとえばCompute Engine、App Engine Google Kubernetes Engine Cloud SQL、Cloud Datastore BigQuery、Networking、Cloud Pub/Subで Stackdriverモニタリング機能を使用できます デフォルトでは Stackdriverログは一定日数だけ保持されます

日数はログの種類で異なります 管理アクティビティ監査ログは フォレンジック用に400日保持されます データアクセス監査ログは 30日だけ保持されます ログは分析や長期保存用にエクスポートできます 学習の際は Stackdriverを実際に使うのが最善です Stackdriverが初めての方は 「Stackdriver Fundamentals」クエストで プロビジョニングと使用を実践できます クエストのURLは コースのリソースセクションにあります

## 課金管理の概要
プロジェクトの管理では 予算と課金の管理も大切です ここで使う基本スキルは 請求先アカウントの作成、プロジェクトのリンク 予算、アラート 課金データのエクスポートの設定です 請求先アカウントの管理とプロジェクトの追加は 課金管理者だけが行えます 既存プロジェクトの請求先アカウントは プロジェクトオーナー兼 変更先アカウントの 課金管理者だけが変更できます プロジェクトの作成時には リンクする請求先アカウントを選択します アカウントが１つだけの場合は それが自動的にプロジェクトにリンクされます アカウントがない場合は 新規に作成して課金を有効にすると 多くのGCP機能を使用できます 過剰な課金を避けるには 予算を作成しGCP使用料を１か所で監視します

予算額を設定したら 通知をトリガーするアラートルールを設定します これで 利用額が予算に近づくペースを把握できます 課金管理者だけが予算アラートを設定できます アラートは 請求先アカウントかプロジェクトに適用できます 予算は指定した金額にするか 前月の利用額に合わせることができます

予算を設定してもAPI使用量は制限されません 予算アラートがトリガーされた後も 課金されサービスは動作し続けます これは重要なことです 作ったゲームの人気がやっと出た後に 課金アラートで停止なんて事態を避けるためです

## コマンドライン インターフェース
最後に考えるのはGCPの コマンドラインインターフェース（CLI）です

これはCloud SDKでよく使います

GCP Consoleには ブラウザから簡単に使えるGCP用のCLIがあります Cloud Shellです Cloud ShellではCloud SDKのツールを インストールせずに使用できます では SDKについて説明しましょう Cloud SDKはGCPでリソースとアプリの 管理に使うツールセットです GCPプロダクトとサービス用の 主なCLIであるgloudツール Google Cloud Storage用のgsutil BigQuery用のbqが含まれます SDKコマンドを使うにはGCP Consoleで Cloud Shellボタンをクリックするだけです 全コマンドがインストールされたVM上のCLIが ブラウザ内に開きます

パソコン オンプレミスサーバー、VM、他のクラウドなど 独自マシンに SDKをインストールすることもできます

SDKのDockerイメージも提供されており コンテナ化されたアプリから 簡単かつクリーンな方法で使えます

## 教材へのリンク
* [Google Cloud Platform の概要](https://cloud.google.com/docs/overview/) 
* [Google Cloud Identity](https://cloud.google.com/identity/)
* [Google Cloud 料金計算ツール](https://cloud.google.com/products/calculator/)
* [Google Cloud Billing のドキュメント](https://cloud.google.com/billing/docs/)
* [Stackdriver の基礎クエスト](https://www.qwiklabs.com/quests/35)
* [Cloud SDK のインストールとクイック スタート](https://cloud.google.com/sdk/#Quick_Start)
* [gcloud ツールガイド](https://cloud.google.com/sdk/gcloud/)

# 3.クラウドソリューションのプランニングと設定
ACE試験対策の モジュール３へようこそ ここでは クラウドソリューションの計画と構成を扱います 本モジュールは公式ACE試験学習ガイドの セクション２に対応しています ここではまず Google Cloudの料金計算ツールを使用します 新規プロジェクトの設定では 最初に予算を設定します 特定のクラウドプロダクトの料金は 複数の要素によって決まるので 最初にプロダクトを構成せずに そうした情報をまとめて統合レポートを作れたら 便利ですね こんなときに役立つのが Googleの料金計算ツールで 複数のセクションから成るフォームです 設定の候補がいくつかある場合は 使用する予定の各プロダクトに対して 費用を見積もれます 料金計算ツールでは 見積もり費用の合計を １日、週、月、四半期、年、３年単位で 確認できます ただしこれは見積もりに過ぎず 合計費用は見積もりでの使用量と 実際の使用量の差異によって変化します この見積もりは法的拘束力を持たず 計画用のツールにすぎません 料金計算ツールの仕組みを 見てみましょう
## 料金計算ツールのデモ
このデモではGCPの料金計算ツールを使って 費用を見積もります 始めましょう 計算ツールの使用手順を紹介します まずフォーム上部のスクロールリストから プロダクトを選択します ここでは Compute Engineを選択し 仮想マシンを作成します

次に ターゲットの構成を フォームに記入します ここでは仮想マシンを３つ作成し ウェブサーバー向けに使用します

無料のオペレーティングシステムを 使用します Debian、CentOS CoreOS、Ubuntuなどです

VMクラスは[Regular]です インスタンスタイプは[n1-standard-4]を 使います

残りの項目はデフォルトにして 見積もりに追加します 費用の見積もりが横に表示されます

永続ディスクを追加、削除して 見積もりの増減を見てみることもできます 下にスクロールして[永続ディスク]に移動し さまざまなディスクを追加してみましょう SSDは標準的なディスクより 高価なので SSDを追加して

見積もりに加えると

費用は増加します SSDを削除し 標準的なディスクを追加すると

SSDの場合より 費用は減少します

鉛筆アイコンをクリックすると フォームが編集モードに戻り 他の組み合わせを試せます

## コンピューティング リソースの計画と構成
次に扱うのは プロジェクトのコンピューティングリソースの 計画と構成です コンピューティングリソースとは 演算に使用する 仮想マシンとサーバーのことです コンピューティングリソースには 多様な種類があり それぞれに強みや 特別な機能があります プリエンプティブルVMは 別の機会に紹介します ここで紹介するのはCompute Engineと Kubernetes Engine、App Engineの違いや プロジェクトに最適な コンピューティングリソースの決め方です この決定チャートでは これら３つの選択肢と それぞれの特別な機能や 主なユースケースをリスト化しています たとえば 特別なランタイム要件のない アプリ型プログラムを作成する場合 それをサポートするサーバーの構成や管理が 不要ならば App Engineが最適でしょう コンテナ化したプログラムや マイクロサービスを オンプレミスやクラウド環境で 実行する必要があれば Google Kubernetes Engineを選ぶのが 合理的です これでコンテナ化したアプリの オーケストレーションが実現し 特定のOSや場所で実行するという要件も 不要になります

この決定テーブルを使って学習する場合 コピーしてヘッダー以外のテキストを削除し 記憶からテーブルを 完成させてみましょう 元のテーブルと比較すれば さらに学習すべき箇所を すぐに把握できます

## データ ストレージの計画と構成
演算のワークロードがある場合 要件や結果として データがほぼ常時発生することになります このデータの扱い方と 保存先は クラウドソリューションの計画時に 考慮すべき課題です ここではデータストレージに関する ２つのことに着目します １つ目は動的データで アプリのレポートを 生成するのに使います データを保存する最適のデータベースを 決める必要があります ２つ目は画像やファイルなどの より静的なデータです 多くの場合 データの保存や取得には費用がかかります 最近はペタバイト単位のデータを管理する 企業もあるため 大きな出費になりえます 最初のサブセクションでは GCPの各種データベースサービスの 違いと長所を説明します このチャートにあるように データストレージとデータベースには ６つの選択肢があり 保存データの構成方法に基づき ４つのカテゴリに分かれています リレーショナルデータベース（RDB）は 多くの人が使っており 構造化された行と列で情報を保存し SQLを使ってデータを取得します Cloud SQLやCloud Spannerが このタイプのデータベースです RDBのユースケースは 多様ですが eコマースサイトやコンテンツ管理システムを 作動させる情報が必要な場合 従来のRDBの いずれかを選択するとよいでしょう 特定のタイプの財務データには データ整合性を維持できるように構造化された RDBが必要です 非RDBでは データが構造化しないで保存され ドキュメントデータベースとも呼ばれます データの構造が柔軟なため 受信データの形式は経時的に変化します たとえば 新しいレコードに 情報を随時追加していっても 古いデータの整合性を保ちながら 元のデータ形式を維持できます Cloud DatastoreとCloud Bigtableが このタイプのデータベースです 非RDBの ユースケースには RDBのユースケースとの 共通点があります 大量の特徴量を短時間でプロジェクトに 反復適用または追加する場合 非RDBを使えば 新しい特徴量のフィールドを追加でき データベース全体を 毎回再構築する必要がなくなります 大量のデータトラフィックが 想定される場合 Cloud Bigtableを使えば対処できます 別種のDBストレージである オブジェクトデータベースでは バイナリラージオブジェクト（blob）として データを保存します このようなDBには Cloud Storageがあります 大量の画像などのバイナリメディアを 演算時に保存する必要がある場合 Cloud Storageを選択するのが合理的です 最後にウェアハウス規模のDBである BigQueryを紹介します BigQueryもSQLを使用しますが 大量の負荷の処理に特化しているので リアルタイムのデータストリーミングや 分析、レポートをDBで処理できます データストレージでは フルマネージドサービスの採否も検討します Googleのデータストレージ製品の多くは フルマネージドのため アップグレードや 定期的なメンテナンスは不要ですが データのバックアップは 確認する必要があります このテーブルを空白にして 記憶に基づいて埋めていけば これまでの学習で見落としていた部分を 特定できます データストレージで 考慮すべきもう１つの点は ファイルの保存方法の選択です Cloud Storageでは４種類の ストレージクラスから選択できます Regional、Multi-Regional Nearline、Coldlineです このように考えてみましょう Multi-RegionalとRegionalは 高性能なオブジェクトストレージ用で NearlineとColdlineは バックアップやアーカイブ用です Multi-Regional Storageは 頻繁に利用するデータやウェブサイトコンテンツ インタラクティブ型ワークロード モバイルアプリやゲームアプリのデータの 保存に最適です 反対にRegional Storageは Compute Engine VMや Kubernetes Engineクラスタに近いデータの 保存に使われます この近接性により 大量データ処理の性能が向上します ストレージクラスの可用性は さまざまです 最も高いのはMulti-Regionalで99.95% これにRegionalの99.9% NearlineとColdlineの99.00%が続きます Regional Storageでは 特定のGCPリージョンにデータを保存できます リージョンはus-central-1、europe-west-1、 asia-east-1です Multi-Regional Storageより低コストですが 冗長性は下がります 逆にMulti-Regional Storageはコストが高く 地理的に冗長です そのため米国、EU、アジアなど 幅広い地理的ロケーションに対応しています Cloud Storageではデータを 160km以上離れた ２つ以上の地理的ロケーションに保存します Nearline Storageは 低コストで耐用性が高く アクセス頻度の低いデータの保存に最適です Multi-Regional Storageや Regional Storageと比べると 月１回以下の頻度で データの読み取りや変更を行う場合に有効です たとえば継続的に Cloud Storageへファイルを追加し 分析のために月に１度アクセスする場合 Nearline Storageが最適です Coldline Storageは非常に低コストな 耐用性の高いサービスで データのアーカイブ、オンラインバックアップ 障害復旧に有効です 可用性が低いため 年１回以内の頻度で アクセスするデータの保存に最適です 最低保存期間は90日で データアクセスに費用が発生し オペレーションあたりのコストも 高くなります データのアーカイブや障害復旧イベント発生時に アクセスが必要な場合に最適です ストレージ料金は 毎月 全ストレージクラスで 保存データ量に対しGB単位で発生します 料金はMulti-Regionalが最も高く Coldlineが最も低いです 下り料金とデータ転送料金も 発生します これらの料金に加え Nearline Storageでは読み取るデータ量に対し GB単位でアクセス料金が生じます Coldline Storageではこの料金が さらに高くなります

## ネットワーク リソースの計画と構成
前回のテーマはクラウドソリューション向けの ネットワークリソースの計画と構成でした 演算用のリソースを確保し データの保存方法を決めたら サーバーとデータへのアクセスを 構成する方法を決定します このセクションでは 負荷分散について説明します 負荷分散とは 同一のサーバーを複数用意するか サーバークラスタを作成し 負荷が過大な場合や サーバーに障害が発生した場合に 残りのサーバーが負荷処理を 分担または引き継ぐことです これにより可用性の高いアプリや サービスを作成できます 負荷処理により 複数のサーバーやサーバークラスタを 単一の演算リソースとして使用でき 必要に応じて サーバーやサーバークラスタの追加や削除を 構成することもできます これを自動スケーリングといいます ウェブアプリ向けに クロスリージョンの負荷分散が必要なら HTTPS負荷分散を使用しましょう セキュアソケットレイヤの トラフィックでは グローバルSSLプロキシロードバランサを 使います セキュアソケットレイヤを使用しない TCPトラフィックでは グローバルTCPプロキシロードバランサを 使います この２つのプロキシサービスは 特定のポート番号のみで機能し TCPだけで使用できます UDPや他のポート番号の トラフィックを負荷分散するには リージョンロードバランサを使い GCPリージョン全体で負荷を分散できます イントラネットからグローバルネットワークへの トラフィックにこれらすべてを使用できますが プロジェクト内でのトラフィックの負荷を アプリのプレゼンテーションレイヤと ビジネスレイヤ間で分散したい場合は 内部ロードバランサを使用します GCPの内部IPアドレスの トラフィックを受信し Compute Engine VMで 負荷分散します Cloudロードバランサで 考慮すべき項目は グローバルと リージョンの負荷分散 外部と内部の負荷分散 そしてトラフィックの種類です グローバル負荷分散は ユーザーとインスタンスが世界中に点在し ユーザーが同一のアプリとコンテンツへの アクセスが必要で 単一のユニキャストIPアドレスで アクセスを提供する場合に有効です グローバル負荷分散は IPv6終端も提供します リージョン負荷分散は ユーザーとインスタンスが 単一のリージョンに集中していて IPv4終端が必要な場合にのみ使用します グローバル負荷分散では Network Service Tiersの プレミアムティアを使います リージョン負荷分散では スタンダードティアを使います GCPのロードバランサは 外部および内部ロードバランサに分かれています 外部ロードバランサは GCPネットワークから イントラネットへのトラフィックを分散します 内部ロードバランサはトラフィックを GCPネットワーク内で分散します ロードバランサが処理するトラフィックの種類も 使用するロードバランサを決める際に重要です HTTPおよびHTTPSのトラフィックには グローバルな外部負荷分散が必要です TCPトラフィックの処理は グローバルな外部負荷分散や リージョン外部負荷分散 リージョン内部負荷分散で行います UDPトラフィックの処理は リージョン外部負荷分散や リージョン内部負荷分散で行います

## 教材へのリンク
* [Google Cloud の料金の概要](https://cloud.google.com/pricing/)
* [Google Cloud 料金計算ツール](https://cloud.google.com/products/calculator//)
* [Google の料金設定の基本的な考え方](https://cloud.google.com/pricing/philosophy/)
* [Compute Engine のドキュメント](https://cloud.google.com/compute/docs/)
* [GCP での適切なコンピューティング オプションの選択](https://cloud.google.com/blog/products/gcp/choosing-the-right-compute-option-in-gcp-a-decision-tree)
* [コンピューティング オプションの選択](https://cloud.google.com/docs/choosing-a-compute-option)
* [ストレージ クラス](https://cloud.google.com/storage/docs/storage-classes)
* [Google Cloud Storage のオプション](https://cloud.google.com/storage-options/)
* [負荷分散](https://cloud.google.com/load-balancing/docs/load-balancing-overview)

# 4.クラウドソリューションのデプロイと実装
Associate Cloud Engineer試験対策の モジュール４へようこそ クラウドソリューションの デプロイと実装について説明します このセクションは 少し長くなっていますが ご安心ください ここでは これらのことを扱います まずはCompute Engineリソースの デプロイと実装について紹介します これらは試験で出題されるかもしれない Compute Engineのデプロイタスクです 今後の多くのセクションでは 実践的な知識を問われます このコースで確認するのは １～２番目のタスクの資料で Cloud ConsoleとCloud SDKを使った Compute Engineインスタンスの起動と 自動スケーリング マネージドインスタンスグループの作成です まず Compute Engineの概要と 一般的な用途を確認しましょう Compute Engineを使えば GoogleのインフラでVMを作成して実行できます 事前投資をせずに 高速で一貫したパフォーマンスを実現する システムで数千の仮想CPUを実行できます Compute Engine VMインスタンスの作成には GCP Consoleか gcloudコマンドラインツールを使います VMではGoogle提供の Linux、Windows Serverのイメージや これらをカスタマイズしたイメージを実行し 多くの物理サーバーから イメージをインポートすることもできます VMの作成時には マシンタイプを選択し メモリの容量や 仮想CPUの数を決める必要があります これらの規模は非常に幅広くなっており ニーズに合った 事前定義済みのVMタイプがない場合 カスタムVMを作成できます

処理能力についてですが 機械学習やデータ処理など GPUを利用するワークロードがある場合 多くのGCPゾーンでGPUを利用できます 物理コンピュータと同様に VMにもディスクが必要です 選択できる永続ストレージには 標準とSSDの２種類があります アプリに 高パフォーマンスの一時的領域が必要なら ローカルSSDを使えますが ここにあるデータは VMの終了時に消去されるので 恒久的なデータは 別の場所に保存しましょう 永続ディスクと呼ばれるディスクがあるのは このためです 多くの場合 標準の永続ディスクが デフォルトで使用されます VMインスタンスグループには 非マネージドとマネージドの２種類があります 非マネージドインスタンスは 必ずしも同一でないインスタンスのグループで インスタンステンプレートを共有せず 既存の構成で負荷分散タスクに対応できます マネージドインスタンスグループでは 複数の同一VMでアプリを操作できます 自動スケーリングと自動更新を活用し 高可用性とスケーラビリティを実現します 異なるインスタンスのグループ化が不要ならば 常にマネージドインスタンスグループを 使いましょう インスタンステンプレートを使うと 既存の構成でVMインスタンスをすぐに作成でき マシンタイプ 、ブートディスクイメージ コンテナイメージや ラベル、その他のインスタンスプロパティを 定義できます 同一インスタンスのグループを 作成したい場合 インスタンステンプレートで マネージドインスタンスグループを作成し インスタンス数を 自動で調整できるようにします インスタンステンプレートの目的は 同じ構成のインスタンスの作成なので 既存のインスタンステンプレートの更新や 作成したインスタンステンプレートの変更は できません インスタンステンプレートが最新でない場合や 構成の変更が必要な場合は新規作成します

## Kubernetes リソースのデプロイと実装
Kubernetes Engineリソースのデプロイと実装に 必要なタスクをいくつか紹介します 試験ガイドで特に重視されているのは Kubernetes Engineクラスタのデプロイ手法や Podを使ったコンテナのデプロイ方法 Kubernetes Engineのロギングと モニタリングの構成方法です まず コンテナとKubernetesについて 少し確認しましょう 次の数枚のスライドで コンテナの基本的な概要を確認できます コンテナではワークロードの 独立した拡張性を PaaS、OSの抽象化レイヤ IaaS内のハードウェアで確保できます コンテナはコードと 依存関係を隔離し ファイルシステムとHWの 該当パーティションへのアクセスを制限します わずか数回のシステム呼び出しで すぐに作成および開始できます 各ホストに必要なのは コンテナランタイムでコンテナをサポートする OSカーネルだけです ここで行っているのはOSの仮想化です PaaSのようなスケーラビリティや IaaSとほぼ同等の柔軟性を実現します このように抽象化することで コードの移植性が増し OSとHWをブラックボックスとして 使えるようになるため 開発からステージング、本番環境へ または ノートパソコンからクラウドへ 変更、再作成せずに移行できます ウェブサーバーなどを拡張する場合 数秒で実行でき ワークロードの規模に応じて 数百のウェブサーバーを 単一ホストにデプロイできます 以上が 単一ホストでアプリ全体を実行する コンテナ拡張の簡単な例です マイクロサービスとして 個々に機能する 多くのコンテナを使って アプリを作成する場合 そのように作成したアプリを ネットワークで接続すると モジュラーとなり 複数ホストで簡単にデプロイと 個別のスケーリングができます アプリの変更時やホストの障害発生時に ホストはコンテナのスケーリングや 開始および停止を行えます こうしたことを円滑に行えるのが Kubernetesで 複数ホストでコンテナを簡単に オーケストレートしたり マイクロサービスとしての拡張 ロールアウトとロールバックの デプロイができます さて Kubernetes Engineクラスタと Podでコンテナ化したアプリを デプロイすべき理由を詳しく考えましょう 大まかに言うと KubernetesはAPIのセットで クラスタというノードのセットに コンテナをデプロイする際に使え コントロールプレーンとして実行する マスターコンポーネントのセットと コンテナを実行するノードのセットで 構成されます ノードは Kubernetesではマシンなどの 演算インスタンスを Google Cloudでは Compute Engineを実行するVMを指します アプリのセットと アプリ間でのやりとりについて記述すると Kubernetesはその実行方法を判断します 次に Podというコンテナのラッパーを使って コンテナをノードにデプロイします PodはKubernetesで作成、デプロイされる 最小のユニットです Podが表すのは アプリの一部または全体として クラスタで実行するプロセスです 通常 各Podに含まれるコンテナは １つだけですが 強い依存関係にある 複数のコンテナがある場合 共有のネットワークとストレージで 単一のPodにパッケージ化できます Podは固有のネットワークIPや コンテナ用のポートセット コンテナの実行方法のオプションを 備えています Pod内のコンテナは 互いに通信できますが このとき 固定されたローカルホストとポートを使います Deploymentは 同じPodの複数レプリカを指し Pod実行中のノードでの障害発生時でも Podの稼働を維持できます Deploymentは アプリの一部や全体を指すこともあります この場合はnginxウェブサーバーです 実行中のnginx Podを確認するには コマンド”kubectl get pods”を実行します

## App Engine リソースと Cloud Functions リソースのデプロイ
次はApp EngineとCloud Functionsです これらはGCPのサービスで ご自身での特別なサーバーの維持が 不要な場合に使用します まずはApp Engineの紹介です App Engineの環境には スタンダードとフレキシブルがあり スタンダードの方が簡素です フレキシブル環境では より容易にデプロイを行い より細かく自動スケーリングを行えます スタンダード環境と同様に 毎日無料で各種サービスを一定量使用できます スタンダード環境の特長は 使用率の低いアプリを 無料で実行できる場合があることです GoogleのApp Engineは 複数言語に対応するSDKで App Engineサービスへのアップロード前に ローカルでアプリをテストできます SDKでもシンプルなコマンドで デプロイを行えます App Engineスタンダード環境には Java、Python、PHP、Goの特定バージョンに 対応したランタイムがあり これにはApp Engine APIに対応する ライブラリも含まれます スタンダード環境のランタイムとライブラリで アプリに対応できることも多いです ただし別の言語でコードを書く場合 スタンダード環境よりも フレキシブル環境の方が 適しています スタンダード環境では サンドボックスとして実行されるため コードが制限され ハードウェア、OS、実行サーバーの場所に 関係ないソフトウェア構造になっています これにより App Engineスタンダード環境では アプリを細かく スケーリング、管理できます 他のサンドボックスと同様 制限がいくつかあります アプリはローカルのファイルシステムに 書き込めませんが データの一貫性を保つ必要がある場合 データベースサービスを利用できます

また アプリへのすべてのリクエストに 60秒のタイムアウトが設けられ 第三者製のソフトを インストールできません こうした制限が不都合な場合 フレキシブル環境を選択します この図ではApp Engineスタンダード環境を 使用しています 開発したアプリのテスト版を App Engine SDKを使ってローカルで実行し 問題がなければ SDKを使ってデプロイします 各App Engineアプリを GCPプロジェクトや自動提供された サーバーインスタンスで実行し スケーリングと負荷分散を行います アプリでは専用のAPIを使って さまざまなサービスを呼び出せます データの一貫性を保つための NoSQLデータストアや Memcacheを使ったデータのキャッシュ 検索、ロギング、ユーザーログイン 直接的なユーザーリクエストがなくても アクションを開始できる機能などがあります 次は Cloud Functionsの機能や 他のGCPサービスとの関わりを紹介します Cloud Functionsは軽量、イベントベースで 非同期の演算ソリューションです クラウドイベントに応答する 単一目的の小規模な関数を作成でき サーバーやランタイム環境の管理は不要です これらの機能を使って 簡単なビジネスロジックから アプリを構築できます Cloud Functionsで クラウドサービスの接続と拡張も行えます コードの実行中のみ 100ミリ秒単位で課金されます Cloud Functionsは JavaScript、Python、Goで書かれており GCPのマネージド環境で実行されるほか Cloud StorageとCloud Pub/Subのイベントで 非同期でトリガーされ HTTPを使用すると同期的に呼び出せます

## データ ソリューションのデプロイと実装
クラウドソリューションの データ処理方法をいくつか紹介します たいていの場合 アプリやサービスに データはつきものですから クラウドソリューション向けの データサービスの設定方法や データをデータソリューションに転送し 読み込む方法を把握することは重要です ここではデータソリューションの オプションのみを紹介します データの読み込みについては 推奨のクエストのラボで学べます データストレージと データベースのオプションを復習します 以前見たように これらは いくつかの方法でグループ分けができます リレーショナルや非リレーショナルなどの データの構成による分類や 適したオプションが１つとは限らない 用途による分類もあります この表はストレージサービスの 技術面での違いに着目しています 各行は技術仕様を 各列はサービスを示します サービスを 左から順に１つずつ紹介します Cloud Datastoreは 構造化されたオブジェクトの格納や トランザクションと SQLに似たクエリのサポートに最適です Cloud Datastoreの容量は テラバイト単位で ユニットサイズは 最大で１MB/エンティティです Cloud Bigtableは 大量の構造化されたオブジェクトの格納に 適しています ただしSQLクエリや複数行トランザクションを サポートしていません Cloud Bigtableの容量は ペタバイト単位で ユニットサイズは最大で 10MB/セル、100MB/行です Cloud Storageは 大容量の画像や動画など 10MB超の不変blobの格納に有効です Cloud Storageの容量は ペタバイト単位で ユニットサイズは 最大で５TB/オブジェクトです Cloud SQLやCloud Spannerは オンライントランザクション処理システム用の 完全なSQLサポートに最適です Cloud SQLの容量はテラバイト単位 Cloud Spannerはペタバイト単位です 水平方向のスケーラビリティが必要で Cloud SQLが要件に適合しない場合 Cloud Spannerを検討します BigQueryにデータを保存する目的は通常 ビッグデータ分析や インタラクティブなクエリの実施です オンラインアプリのバックエンドデータストアに BigQueryはおすすめしません

## ネットワーキング リソースのデプロイと実装
セクション3.5では ネットワークリソースの クラウドソリューションへの実装を扱います クラウドソリューション向けの ネットワークリソースは VPC、サブネット カスタムネットワーク構成 IPアドレス割り当て、ファイアウォールの 上りと下りのルール、VPN、負荷分散などです このモジュールの当サブセクションでは 主にVPCサブネットに着目します まずはVPCネットワークについて 振り返りましょう GCPを初めて使う人の多くが驚くのは 定義したVPCネットワークに グローバルスコープがあることです 世界中のどのGCPリージョンにも サブネットがあり リージョン内の複数のゾーンを またぐことができます 複数ゾーンのリソースを 同じサブネットに含めることもでき このアーキテクチャでは ネットワークレイアウトを グローバルスコープで容易に見つけられます GCPを使い始める人の多くは １つ目のGCPプロジェクト内でVPCを定義します また デフォルトのVPCを選択して 開始することもできます いずれの場合も VPCネットワークで GCPリソースの相互接続や インターネット接続ができます ネットワークをセグメント化し ファイアウォールルールで インスタンスへのアクセスを制限して 静的ルートを作成し 特定の宛先にトラフィックを転送できます VPCネットワークの作成時に 自動モードかカスタムモードを選択できます 同じプロジェクトで作成する 新規のネットワークには一意の名前が必要です 自動モードネットワークでは ネットワーク作成時に各GCPリージョンで サブネットが１つ自動作成されます 新しいリージョンが利用可能になると リージョンの新規サブネットが 自動モードネットワークに自動で追加されます 自動作成されたサブネットのIP範囲は 事前定義された範囲のセットに基づき 自動モードネットワークはすべて 同じセットを使います 次はこれらを実装する方法について 後続の２つのデモで確認しましょう

## サブネットを備えた自動モード VPC ネットワークの作成のデモ
このデモでは 自動モードのVPCネットワークを作成します では 始めます まず [VPCネットワーク]ページに 移動しましょう

ナビゲーションメニューや 検索バーを使います

次に [VPCネットワークを作成]を クリックします

ネットワークの名前を入力します とりあえず”mynetwork”とします [サブネット作成モード]で [自動]を選択します

[ファイアウォールルール]では VMへの接続の一般的ユースケースに対処する 事前定義済みルールを１つ以上選択します ここでは SSHを選択しましょう VPCネットワークの 動的ルーティングモードについては [リージョン]か[グローバル]を選択します 詳細もありますので ご覧ください このモードは後で変更することもできます 最後に[作成]をクリックします

作成されたネットワークが 画面下部に表示されます

## サブネットを備えたカスタム VPC ネットワークの作成のデモ
ここではカスタムモードの VPCネットワークを作成します 始めましょう カスタムモードのVPCネットワークでは 新規サブネットを設定できます サブネットは ネットワーク作成時に作成するか 後で追加できます サブネットを持つカスタムVPCネットワークは VPCのページで作成します 今回は検索バーを使って移動します

前回と同様に VPCネットワークを作成します ネットワーク名を入力します 今回は”mynetwork-custom”です

[サブネット作成モード]で [カスタム]を選択し [新しいサブネット]で サブセットの構成パラメータを指定します ここでは サブネット名”mysubnet”を入力します 次に リージョン”us-central1”を追加します IP範囲には サンプルの範囲を使用します

セカンダリIP範囲も作成できるので 名前はrange-1にして サンプルの値を使用します

限定公開のGoogleアクセスを 有効または無効にしたり フローログを有効にしたりできます

最後に[完了]です

サブネットをさらに作成するには [サブネットを追加]から 先ほどの手順を繰り返します ネットワークの作成後 さらにサブネットを追加できます 動的ルーティングモードで [リージョン]か[グローバル]を選択でき この？マークから詳細を確認できます 最後に[作成]をクリックします

[VPCネットワーク]ページに 作成したネットワークが表示されます

## Cloud Launcher によるソリューションのデプロイ
次は Cloud Launcher（Cloud Marketplace）で容易に クラウドソリューションを デプロイする方法です 特にCloud Launcherと その機能に着目します Cloud Launcherは新しいサーバーや ソフトウェアリソースの稼働を迅速化し 機能的なソフトウェアパッケージを すばやくGCPにデプロイします ソフトウェア、VMインスタンス、ストレージ ネットワーク設定を自動で構成できますが 必要に応じてこれらの多くを 運用開始前に変更できます

このサービスのカタログにある 大半のソフトウェアパッケージでは GCPリソースの通常使用料金以外に 追加費用は発生しませんが 一部のCloud Launcherイメージは 使用料が課金されます 商用ライセンスが付与されたソフトを使用する サードパーティ製のものなどです この場合 月額料金の見積もりを 運用開始前に確認できますが この金額は あくまでも見積もりに過ぎず 特にネットワーク料金を考慮していないため 実際の費用はアプリの使用方法により変動します 第２の注意点は GCPはベースイメージの更新によって ソフトウェアパッケージの 重要な問題や脆弱性に対処しますが デプロイ後にソフトを更新しないことです しかしデプロイされたシステムに アクセスできるので最新の状態に保てます

## Deployment Manager によるアプリケーションのデプロイ
次はDeployment Manager（DM）を使った アプリのデプロイについてです 特にDMテンプレートを使った GCPリソースのプロビジョニングに着目します DMはインフラ管理サービスで GCPリソースの作成と管理を自動化します

GCPでの環境設定には 多くのステップが伴うため Computeネットワークやストレージリソース 構成の記録が必要です 命令型アプローチで すべてを手動で行うこともできますが テンプレートを使う方が効率的です これは目的の環境の仕様書であり 宣言型アプローチとなります GCPではこうした作業に DMを使います これはインフラ管理サービスで GCPリソースの作成と管理を自動化します DMを使うには YAMLマークアップ言語やPythonで テンプレートファイルを作成し 目的の環境のコンポーネントについて 記述します DMにテンプレートを渡すと テンプレートに記述された環境を 作成するための操作をDMが行います 環境を変更する場合 テンプレートを編集すると DMが変更を適用してくれます なお DMテンプレートの 保存とバージョン管理は Cloud Source Repositoriesで行えます

## 教材へのリンク
* [Compute Engine](https://cloud.google.com/compute/docs/)
* [Cloud Source Repositories](https://cloud.google.com/source-repositories/docs/)
* [Deployment Manager](https://cloud.google.com/deployment-manager/docs/)
* [インスタンス グループ](https://cloud.google.com/compute/docs/instance-groups/)
* [インスタンスのグループの自動スケーリング](https://cloud.google.com/compute/docs/autoscaler/)
* [インスタンス テンプレート](https://cloud.google.com/compute/docs/instance-templates/)
* [インスタンス テンプレートから VM インスタンスを作成する](https://cloud.google.com/compute/docs/instances/create-vm-from-instance-template)
* [マネージド インスタンス グループの作成](https://cloud.google.com/compute/docs/instance-groups/creating-groups-of-managed-instances)
* [VPC ネットワークの使用](https://cloud.google.com/vpc/docs/using-vpc)
* [Deployment Manager の基礎知識](https://cloud.google.com/deployment-manager/docs/fundamentals)

# 5.クラウドソリューションの確実な運用
## Compute Engine リソースの管理
「Preparing for the Associate Cloud Engineer Exam」 ここではクラウドソリューションの 適切な運用に必要な概念を学びます どれもクラウドリソースの管理に関係します Compute Engine、Kubernetes Engine App Engine、データソリューション ネットワークリソース ロギング、モニタリングです 最初に考えるのは Compute Engineリソースの管理です セクション4.1で 多くのインスタンス管理タスクを学びます この一覧中のタスクを すべて扱うことはしませんが まずVMインスタンスを簡単に復習します VMインスタンスのブートディスクは OSイメージを使って作成できます 複数の種類のイメージがあります 公開イメージは Google、オープンソースコミュニティ 第三者企業が提供、保守しています どのプロジェクトも このイメージからインスタンスを作れます カスタムイメージは特定プロジェクト専用で ブートディスクや他のイメージから作成した後 インスタンスの作成に使用できます

大半の公開イメージは追加費用なしで使えますが 一部のプレミアムイメージでは費用が発生します

カスタムイメージをCompute Engineで使う場合 使用料は不要ですが プロジェクトで使っている間の イメージ保存料金はかかります

一部のイメージは Compute Engineでコンテナを実行できます Compute Engineで提供される 公開OSイメージのサポートは 当該OSのライフサイクルに従います スナップショットは増分であり 自動的に圧縮されるため 永続ディスクの定期的なスナップショットを ディスク全体のイメージを作る場合より 高速かつ低コストで作れます 増分スナップショットの仕組みを説明します スナップショット１は 正常な完全スナップショットで 永続ディスクの全データが入っています スナップショット２には １以降の変更データと新規データだけが入ります 未変更のデータは含まれません その代わりに スナップショット１への参照が含まれます スナップショット３には ２以降の変更、新規データが入り １、２からの未変更データは入りません 代わりにスナップショット１または２内の ブロックへの参照が入ります 以降の各スナップショットで これが繰り返されます 常に最後の正常なスナップショットに基づき 作成されます スナップショットごとに複数のコピーが 複数ロケーションに保存され 自動チェックサムにより データ整合性が確保されます プロジェクトでの共有にはIAMロールを使います 利用できる全スナップショットを見るには gcloud compute snapshots listコマンドを 使います 作成時刻、サイズ、ソースディスクなど スナップショットの情報を見るには gcloud compute snapshots describeを使います カスタムイメージは自分で所有して管理する ブートディスクイメージです 新しい構成やソフトウェアで カスタムイメージを頻繁に更新する場合は イメージをイメージファミリーにできます イメージファミリーでは 常に最新イメージが参照され インスタンステンプレートやスクリプトで 参照を特定バージョンに更新せずに 最新イメージを使えます ディスクイメージは次のソースから作成できます 永続ディスク （インスタンスに接続したものを含む） 永続ディスクのスナップショット プロジェクト内の別のイメージ 別のプロジェクトと共有中のイメージ Cloud Storage内の圧縮済みRAWイメージです

## Kubernetes Engine リソースの管理
次のセクションは Kubernetes Engineリソースの管理です 特にKubernetesのPodを デプロイして管理する方法をさらに学びます

Deploymentは 同じPodのレプリカの集合であり これでノードに障害が起きても Podが稼働し続けられます アプリの コンポーネントや全体を表せます この例ではnginxウェブサーバーです デフォルトではDeployment内のPodには GKEクラスタ内でのみアクセスできます 外部に公開するには kubedtl exposeコマンドで Deploymentにロードバランサを接続できます このとき 固定IPを持つサービスが作成され パブリックIPアドレスを持つ 外部ロードバランサの接続が要求されます サービスを追加してアクセス可能にするためです

GKEで ネットワークロードバランサが作成されます コマンドを使わずとも 目的の状態を示す構成ファイルを提供すれば Kubernetesで処理できます このようにkubectl get podsコマンドで YAMLファイルを取得できます ここではnginx Podの レプリカを３つ使うと宣言されています

selectorフィールドでDeploymentに レプリカのグループ化方法も伝えられます Podテンプレートをラベル付けして 選択可能にもできます 実行レプリカを５つにするには Deployment構成ファイルを更新した後 それを使うよう kubectl applyコマンドを実行するだけです

## App Engine リソースの管理
学習ガイドの次のセクションは App Engineリソースの管理です App Engineインスタンスの 自動スケーリングを学びます App Engineインスタンスは App Engineの基本的な構成要素であり アプリのホストに必要な全リソースを提供します これには言語ランタイム、App Engine API アプリコード、メモリなどが含まれます 各インスタンスには他のインスタンスからの 影響を防ぐセキュリティレイヤがあります

App Engineはインスタンスを使って アプリを自動的にスケーリングします どの時点でもアプリは １つ以上のインスタンスで実行でき リクエストは分散処理されます

インスタンスは常駐または動的です 動的インスタンスは ニーズに応じて自動的に起動、停止します 常駐インスタンスは常に稼働し アプリのパフォーマンスを高めます どちらのインスタンスも App Engineサービスバージョン内の コードから作られます 手動スケーリングでは アプリが常駐インスタンスで実行されます 基本または自動スケーリングでは アプリが動的インスタンスで実行されます

サービスバージョンのアップロード時に app.yamlファイルで インスタンスのスケーリングタイプと インスタンスクラスを指定します スケーリングタイプは インスタンスの作成方法に影響し インスタンスクラスは演算リソース メモリ容量、CPU速度、料金に影響します スケーリングには 手動、基本、自動の３種類があります それぞれで使うインスタンスクラスが違います 手動スケーリングでは常駐インスタンスを使い 負荷に関係なく 指定数のインスタンスが稼働し続けます これは先ほど考えた複雑な初期化や メモリを使い続けるアプリで役立ちます

自動スケーリングでは動的インスタンスを リクエスト率や応答レイテンシなどの アプリ指標に基づいて作成、使用します ただし アイドルインスタンスの最小数を指定すると その数のインスタンスが常駐になり 追加インスタンスが動的になります 基本スケーリングでは動的インスタンスを アプリでのリクエスト受信時に作成して使い アプリがアイドルになると停止します 基本スケーリングは 断続的な処理や ユーザー操作に基づく処理に最適です

## データ ソリューションの管理
次のセクションは ソリューションデータの管理方法です 特にCloud Storageバケット管理で使う ストレージタイプを考えます

バケットには ライフサイクル管理構成を指定できます これには現在と以降のオブジェクトに適用する ルールを含めます

ルールの基準を満たすオブジェクトには 指定した操作が自動的に実行されます 次のような用途があります 365日が過ぎたオブジェクトのストレージを Coldline Storageにダウングレードする 2013年1月1日より前に作成された オブジェクトを削除する バージョニングありのバケットで 最新の３つのバージョンだけを保持する ライフサイクルルールでは次の操作を使えます Deleteは ライブまたはアーカイブオブジェクトの削除です この操作はバージョンの有無に関係なく使えます バージョニングありのバケットでは ライブオブジェクトに使うとアーカイブ アーカイブオブジェクトに使うと 完全削除になります SetStorageClassは オブジェクトのストレージクラスを変更します この操作も バージョンの有無に関係なく適用できます ルールでは次の条件を使えます Age条件は 指定日数に達したオブジェクトが満たします CreatedBefore条件は 指定のUTC日付の深夜0時より前に作られた オブジェクトが満たします isLive条件はtrueの場合 ライブオブジェクトに一致します falseの場合は アーカイブオブジェクトに一致します MatchesStorageClassは 指定のストレージクラス内の オブジェクトに一致します NumberOfNewerVersionsは バージョンありオブジェクト用で 指定した値Nに基づき より新しいバージョンがライブバージョンを含め N個以上あるオブジェクトに一致します ライブオブジェクトではこの数はゼロとなります

## ネットワーキング リソースの管理
次はネットワークリソースの管理です CIDRブロックサブネットの拡張方法を学びます その前にVPCネットワークとサブネットの 主な要件を復習しましょう VPCネットワークでは 各サブネットでプライマリ範囲が必要で エイリアスIP用に 最大５つのセカンダリ範囲も使えます プライマリとセカンダリのIP範囲は RFC 1918アドレスである必要があります VPCネットワークでプライマリと セカンダリのIPアドレスは一意にしますが 連続させる必要はありません たとえば あるサブネットのプライマリ範囲を 10.0.0.0/24にし 同じネットワーク内の別のサブネットの プライマリ範囲を192.168.0.0/16にできます サブネットのセカンダリIP範囲の削除や置換は 使用中でない場合にのみ行なえます サブネットのプライマリIP範囲は拡張できますが 作成後の置換や縮小はできません プライマリ、セカンダリ範囲の最小サイズは IPアドレス８つで つまり 使用できる最長のサブネットマスクは/29です

## サブネット IP の拡張のデモ
このデモでは 既存サブネットのIP範囲を拡大します 始めましょう 既存サブネットのプライマリIP範囲を広げるには サブネットマスクを変更し プレフィックス長を小さくします 新しいプライマリIP範囲は 次のサブネットルールに従う必要があります 自動作成されたサブネットの IP範囲を広げる場合 自動モードでも 元が自動モードの カスタムモードでも 最長のプレフィックス つまりサブネットマスクは/16です /16より長いプレフィックスは 自動作成されたサブネットの プライマリIP範囲と競合します これを [VPCネットワーク]ページで行いましょう

プロジェクト内のサブネットは階層表示され ネットワーク内のエントリとして示されます ネットワーク名のクリックで そのサブネットが表示されます 今回はdefaultを選びます

[VPCネットワークの詳細]で [サブネット]タブのサブネット名を見て 詳細ページを開きます us-central1にしましょう

[編集]を選びます

サブネットマスクを編集します 今回は最長の値である16にします これが新しいCIDRブロックです [保存]をクリックします

有効になった変更が サブネットの詳細ページに表示され ネットワークにも反映されます

## モニタリングとロギング
最後に考えるモニタリングとロギングも 大切なトピックです ここではソリューションの安全で正常な動作を 保証するモニタリングについて学びます Stackdriverはクラウドインフラからの 指標、ログ、イベントを集約し 豊富な観測可能データと指標を提供して セキュリティやパフォーマンスの問題の 迅速な解決を助けます App Engineフレキシブル、 App Engineスタンダード GKEなどは Stackdriverモニタリングを内蔵します Compute Engineなど この機能を内蔵しないサービスでは モニタリングエージェントを使えます Amazon EC2オンプレミスサービス用の エージェントもあります マルチクラウドのハイブリッド モニタリングソリューションが可能です またアラートポリシーの作成と管理を Stackdriver MonitoringのコンソールやAPI、 Cloud SDKにより行えます 各ポリシーでは リソースまたは リソースグループの正常性を判断する条件のほか リソースの異常をサポートチームに伝える メールやSMSなどの通知と 問題解決を助けるために 通知に含めるドキュメントを指定できます

イベントにより ポリシー内の条件がトリガーされると インシデントが作成されて コンソールに表示されます 通知を設定した場合は 担当者や第三者通知サービスに通知が送られます 受信者は通知に確認応答できますが リソースが正常に戻るまで インシデントは対応待ちのままです 「Site Reliability Troubleshooting with Stackdriver APM」ラボでは Stackdriverの 動作を確認して設定を実践演習できます

## 教材へのリンク
* [VM イメージ](https://cloud.google.com/compute/docs/images)
* [カスタム イメージの作成、削除、使用中止](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images)
* [スナップショットの作成](https://cloud.google.com/compute/docs/disks/create-snapshots)
* [App Engine インスタンスの管理方法](https://cloud.google.com/appengine/docs/standard/python/how-instances-are-managed)
* [オブジェクトのライフサイクル管理](https://cloud.google.com/storage/docs/lifecycle)
* [サブネットの拡張](https://cloud.google.com/vpc/docs/using-vpc#expand-subnet)
* [アラートの概要](https://cloud.google.com/monitoring/alerts/)
* [アラート ポリシーの管理](https://cloud.google.com/monitoring/alerts/using-alerting-ui)

# 6.アクセスおよびセキュリティの設定
## Identity and Access Management（IAM）の管理
Associate Cloud Engineer試験対策へ ようこそ 今回はクラウドソリューションや アクセス、セキュリティの構成方法です 最初のセクションでは IDとアクセスの管理（IAM）を紹介します ここで扱うのはIAMロールの表示と アカウントやGoogleグループへの割り当てです まずはCloud IAMの基本を おさらいします アクセス権は 次のメンバーに付与できます Googleアカウントはデベロッパーや管理者、 GCPを扱う人物を指します サービスアカウントはエンドユーザーではなく アプリに属するアカウントです GoogleグループはGoogleアカウントと サービスアカウントのコレクションで 各自にグループと紐づいたメールアドレスが 付与されます G Suiteドメインは組織のG Suiteアカウントで 作成した全Googleアカウントの仮想グループです Cloud Identityドメインは G Suiteドメインに似ていて 組織の全Googleアカウントの 仮想グループを指します ただしCloud Identityドメインユーザーは G Suiteのアプリと機能を利用できません IAMを表示するには GCP Consoleの[IAM]ページを開いて [プロジェクトを選択]、[開く]を 選択します プロジェクトのメンバーの ロールに関するリストが表示されます 新規メンバーのプロジェクトへの追加や メンバーのロール変更 アクセス権の取り消しについては 次のデモで紹介します

## IAM メンバーの管理のデモ
このデモでは新規のチームメンバーを プロジェクトや Cloud IAMロールに追加します 始めましょう チームメンバーをプロジェクトに追加し Cloud IAMロールを付与するには [IAM]ページを開きます

プロジェクト、[開く]を選択します ここではQwiklabsプロジェクトを 開いてあります [追加]をクリックします ここは私自身alexhanna@google.comを追加し ロールを選択します プロジェクト閲覧者に設定します [保存]をクリックします

ロールはメンバーに相応の権限を 付与するものであり 与える権限は 必要最低限としておくのがおすすめです オーナーレベル権限を与えれば プロジェクトのオーナーとして プロジェクトの管理 削除もできます 追加する際は注意しましょう 複数のプロジェクトで ロールを付与するには [IAM]ページで [リソースを管理]をクリックし 権限を付与するプロジェクトを すべて選択します 表示された情報パネルで [権限]タブをクリックします ここでの設定はデフォルトです [メンバーを追加]フィールドに メールアドレスを追加してロールを選択します

ここでは 私のGmailアドレスを追加します その後 別のロールをクリックします 最後に [保存]ボタンをクリックします プロジェクトへのアクセス権を 取り消すには 先ほどのように [IAM]ページを開き

取消し対象のユーザーの横にある チェックボックスをクリックし [削除]をクリックします ユーザーの削除に関して確認を求められたら [確認]をクリックします

## カスタム IAM ロールの定義
次は IAMのカスタムロールを紹介します Cloud IAMでは 事前定義ロールの他に カスタマイズしたCloud IAMロールを 作成できます カスタムロールの作成では 割当先のリソースで利用できる権限を 把握する必要があります そのうえで 権限を持つ カスタムCloud IAMロールを作成し 組織に属するユーザーに付与します ロールメタデータでは 付与できる権限を確認できます このロールメタデータはGCPやIAM APIを 使うことで確認できます ロールの名前や 付与する権限を決めれば 簡単にロールを作成し 権限を追加できます この際 ユーザーアカウントやロールで ”iam.roles.create”権限が必要です キュレートされたロールを基に カスタムロールを作成することもできます 作成したいロールと似たロールを見つけて 必要に応じて そのロールのコピーから 権限を追加または削除します 次のデモで カスタムロールを作成します

## カスタム IAM ロールの定義のデモ
このデモではGCP Consoleで カスタムロールを作成します まず [ロール]ページを開きましょう [IAMと管理]、[ロール]をクリックし [ロール]ページを開きます

リソースの管理者ロールを オンにすると リソースに適用できる権限を 確認できます Computeインスタンス管理者を 選択すると Compute Engineインスタンスに適用できる権限が すべて右側に示されます ここではまずCompute管理者と Computeインスタンス管理者を検索します

ベータ版とv1がありますが ベータ版を選びます

チェックボックスをオンにして ロールが持つ権限をすべて表示できます

カスタムロールを作る前に 事前定義ロールとカスタムロールの メタデータが必要な場合もあります ロールメタデータにはロールのIDや 権限が含まれます GCP ConsoleやIAM APIを使って メタデータを確認できます

ここでは複数のロールを追加し ロールの権限を表示できます ロールの横にあるアイコンですが 工場のアイコンはカスタムロールを 六角形のアイコンは事前定義ロールを示します “iam.role.create”権限を持つ呼び出し元だけが カスタムロールを作成できます プロジェクトや組織のオーナーは デフォルトでこの権限を有し カスタムロールを作成、管理できます 組織の管理者など オーナーではないユーザーには 組織ロールかIAMロールの管理者ロールを 割り当てる必要があります 新しいロールをゼロから作成する場合は この[ロール]ページに移動し [ロールを作成]をクリック

ロールの名前としてタイトル さらに説明を入力します ここでは デフォルトの“カスタムロール”を使用し 作成日とIDを入力したら [権限を追加]をクリックします

ロールに含める権限を選択し [追加]をクリックします 全サービスとタイプのドロップダウンで サービスとタイプ別に 権限をフィルタリングして選択します ここでは“Compute”でフィルタリングします

追加するロールをクリックします

チェックボックスと [追加]をクリックします 最後に 下までスクロールして [作成]ボタンを押します

既存のキュレートされたロールを基に 新規のカスタムロールを作成します [ロール]ページで

ロールを選択します “Computeインスタンス管理者（ベータ版）” にします

チェックボックスを選択し [選択内容からロールを作成]をクリック ここには新しいタイトル “カスタムのComputeインスタンス管理者”や 新しい説明とIDが表示されます このロールから削除したい権限を オフにします さらに権限を含めるには [権限を追加]を選択します 最後に 下までスクロールして [作成]ボタンをクリックし 既存のキュレートされたロールを基に 新規のカスタムロールを作成します

## サービス アカウントの管理
次に サービスアカウントの管理について説明します 今回はスコープを制限した 特殊アカウントの管理についてです まずは サービスアカウントについてですが これはアプリやVMに属する 特別なGoogleアカウントで 個々のエンドユーザー向けに設定できます アプリではこれを使って サービスのGoogle APIを呼び出します ユーザーは直接的に関わりません Compute Engine VMを サービスアカウントとして実行すれば 必要なリソースへのアクセス権を アカウントに付与できます こうしてサービスアカウントは サービスのIDとなり アカウントの権限は サービスが利用できるリソースを制御します サービスアカウントはアカウント固有の メールアドレスで識別されます 以前はアクセススコープで VMの権限を指定していました IAMのロールの登場前は アクセススコープがサービスアカウントに 権限を付与する唯一の手段でした 今ではあまり 使用されていませんが インスタンスを構成しサービスアカウントとして 実行する際に必要です ロールの権限とスコープの権限も 一致する必要があります そうしないと サービスアカウントは うまく機能できません スコープは“auth”までのベースURLと 付与されている特定の権限で構成されます この例をご覧ください また gcloudコマンドで一連のスコープを使って スコープを設定できます VMインスタンスはロールがサービスアカウントに 付与したオペレーションと インスタンスで定義したスコープのみを 実行でき これらの権限は一致している必要があります ロールがリソースの閲覧権限のみを許可し スコープが追加の権限を許可している場合 インスタンスは リソースを編集できません 編集できるようにするには ロールの権限がスコープで付与される権限と 一致するようにしましょう つまり 編集を許可するのです インスタンスでアクセススコープを 変更した場合 インスタンスを停止、再起動するまで 変更は現れません プロジェクトでVMの各グループに 固有のIDを付与できるので グループのさまざまな権限を 管理しやすくなります VMを再作成しなくても サービスアカウントの権限を変更できます この例では component_1を実行するVMに サービスアカウント１を使って project_bへの編集者権限を付与します component_2を実行するVMには サービスアカウント２を使って bucket_1への閲覧アクセス権を付与します VMを再作成しなくても 変更できますね より複雑な例を紹介します Compute Engine VMのグループに 実装したアプリがあるとします そのコンポーネントの１つには 別プロジェクトの編集者ロールが必要で その他には不要である場合 VMの各サブグループ用にサービスアカウントを ２つ作成する必要があります １つ目にのみ 別プロジェクトでの権限を与えることで 誤って引用されたアプリや不正使用されたVMから 生じうる影響を軽減します

プロジェクトでサービスアカウントに アクセス権を付与する方法を紹介します VMを別のIDとして実行する場合や 必要なAPIの呼び出しでインスタンスに 別のスコープセットが必要な場合は 既存インスタンスのサービスアカウントと アクセススコープを変更します アクセススコープを変更して 新しいAPIへのアクセスを許可したり インスタンスを変更して 作成したサービスアカウントを Compute Engineの既定の代わりに 実行したりできます ただし インスタンスを一時停止しないと このような変更は行えません その方法については 関連ドキュメントを ご確認ください 変更後は インスタンスを再起動しましょう 次のラボでは実際にサービスアカウントを管理し 使ってみます

## プロジェクトとサービスの監査ログの表示
最後はプロジェクトやマネージドサービスでの 監査ログの使い方です 監視ログはセキュリティ管理や クラウドサービスの維持に役立ちます Cloud Audit Loggingでは プロジェクト、フォルダ、組織ごとに ３つの監視ログを出力します 管理アクティビティ、システムイベント データアクセスです GCPはこれらのログに 適切な監査ログエントリを提供し GCPプロジェクト内のユーザーアクティビティを 把握できるようにします ログに含まれる情報には まずリソースが挙げられます 監査ログエントリごとに 何かしらのリソースが含まれ 単一のCompute VMインスタンスや 全VMインスタンスから 監視ログエントリを表示できます 次はサービス サービスとはCompute Engine、Cloud SQL Cloud Pub/SubなどのGCPプロダクトを指し 各サービスは名前で識別されます Compute Engineは compute.googleapis.com Cloud SQLは cloudsql.googleapis.comなどです Cloud監視ログはメインコンソールのメニューから Stackdriverインターフェースで確認します プロジェクト内のVMインスタンスでの 監査ログを見るには メインコンソールのメニューの [Stackdriver]に移動します メインの見出しの下に Stackdriverのオプションがあります [ロギング]、[ログ]と選択し ログエントリを表示します プロジェクトレベルの 簡略化した監視ログを GCP Consoleのプロジェクトの [アクティビティ]ページで確認できます [ホーム]、[アクティビティ]ページと移動し 確認したいエントリをフィルタで選択します これらのエントリは簡略化されており 実際の監査ログエントリと比べて 含まれる情報が少ない場合があります

## 教材へのリンク
* [Google Cloud IAM](https://cloud.google.com/iam/docs/)
* [Security and Identity Fundamentals クエスト](https://www.qwiklabs.com/quests/40)
* [Cloud IAM の概要](https://cloud.google.com/iam/docs/overview)
* [IAM 役割について](https://cloud.google.com/iam/docs/understanding-roles)
* [IAM のカスタムの役割について](https://cloud.google.com/iam/docs/understanding-custom-roles)
* [IAM でのアクセス権の付与や変更](https://cloud.google.com/iam/docs/granting-changing-revoking-access)
* [サービス アカウントについて](https://cloud.google.com/iam/docs/understanding-service-accounts)
* [サービス アカウント](https://cloud.google.com/iam/docs/service-accounts)
* [Cloud Audit Logging の概要](https://cloud.google.com/logging/docs/audit/)
* [監査ログを生成するサービス](https://cloud.google.com/logging/docs/audit/#services)

## 
