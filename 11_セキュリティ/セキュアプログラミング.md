## セキュアプログラミング
* 設定漏れ：SQLインジェクションの脆弱性
    + エラーメッセージの確認：必要最低限の内容となるように制限する
    + キャッシュの残骸
* 抜け道　：ブラウザの設定でスクリプトを無効化する
* 抜け道　：攻撃者は、画面２－１を経由させずに直接画面２－２へアクセスさせるから 
* 脆弱性Xをつく攻撃を防げること。Eシステム利用のための正常な通信が許可されること
* デバッガで、SQL分の発行直前にブレークポイントを設定して、２つの予約処理を並行して実行する 
* 呼び出し元関数への戻りアドレス 
* YoyakuCodeの値がAuthKeyに対応する予約明細コードでないときはアプリケーションエラーを返す 
* 攻撃を成功させるためのジャンプ先アドレスの特定 
* あるアプリから、ほかのアプリのデータへのアクセスを禁止するという仕様 
* ヘッダ部の列数と各ピクセルのバイト数の積にパディングを加えたものと行数の席がｋMaxIntegerを超える 
* ヒープメモリの確保方法が、メモリ確保のライブラリによって違うから 
* データ実行防止機能では、ヒープ領域を書き換える行為を防止できない 
* 整数オーバーフロー 
* バッファオーバーフロー
* リバースエンジニアリング
* ブルートフォース攻撃
* Same Origin Policy：「スキーム(http,https)＋ホスト＋ポート」の組み合わせが全て一致すること。反対の意味はクロスオリジン
* クリックジャッキング
	+ HTTP レスポンスヘッダに、X-Frame-Optionsヘッダフィールドを出力し、他ドメインのサイトからの frame 要素や iframe 要素による読み込みを制限する
	+ 処理を実行する直前のページで再度パスワードの入力を求め、実行ページでは、再度入力されたパスワードが正しい場合のみ処理を実行する
### 原則
* フェイルファースト
	+ できる限り早く失敗させる
* フェイルセーフ
	+ 出力データの無害化
* ゼロトラスト
	+ 何も信頼せず、検証した範囲内で信頼する
	+ 入力データの完全なバリデーション
		- 入力が妥当なデータのみを受け入れる
	+ 出力データの無害化
### クロスサイト攻撃対策
	CSP は、あらかじめその Web ページで読み込まれることが想定されている JavaScript などのコンテンツを、ホワイトリストとして指定することによって、攻撃者によって挿入される悪意のあるスクリプトの読み込みや実行を遮断し、XSS など、インジェクション攻撃から Web サイト や Web アプリケーションを保護するための仕組み
#### クロスサイトスクリプティング(XSS)
	訪問者に目的のサイトとは別の罠サイトを踏ませて不正な処理を実行させる行為。
* 主な対策
	+ Cookie使用時にHttpOnlyを付ける
	+ CookieにSecure属性を付ける
* DOM Based XSSの増加
	+ ソース
		``` 
			location.href、location.search、location.hash、document.cookie、document.referrer、window.name、localStorage、sessionStorage
		``` 
	+ シンク
		``` 
			document.write、element.innerHTML、eval、setTimeout、setInterval、jQuery(),$(), $.html()
		```
	+ 対策
		- JavaScriptライブラリの更新
		- DOM操作APIの適切な使用
		- 扱うURLをhttpおよびhttpsに限定する
* エコーバック対策
1. HTTP レスポンスヘッダーに文字コードを指定する
2. HTML 要素の属性は""(ダブルクオーテーション)で囲む
3. 出力する全ての要素に対してエスケープ処理を行う
4. URL は「http://」か「https://」で始まるもののみ出力する
5. <script></script> 要素の内容を動的に生成しない

#### クロスサイトリクエストフォージェリ(CSRF)
	正規の利用者に意図せず何らかの操作(書き込み、パスワードの変更etc..)を行わせる。
* 主な対策
	+ 処理画面の直前にトークンを埋め込む
	+ Refererのチェック
	+ 重要な処理の前にパスワードの再入力をさせる

### インジェクション対策
#### 入力対策
* パラメータのバリデーション
	+ 不正な入力（仕様上、ありえない値）は拒否するべき
		- ホワイトリスト方式で必要な入力のみを許可
	+ 入力ミスの値（仕様上、あり得る値）は受け入れるべき
		- ロジックで入力ミスを防ぐことはOK
	+ データの安全性と妥当性を確かめ、証明できない方法は不十分
		- 入力値そのものの検証
		- ロジック上の不正検証
* プレースホルダとバインディングの使用
#### 出力対策
* エスケープ
* APIの利用
* サニタイズ
	+ 改行コードを削除する
	+ 改行の後に空白を入れる
	+ 改行コード以降の文字を削除する
* エラーメッセージをそのまま表示しない
#### その他
* データベース権限を適切に割り当てる（必要最小限）

### バッファオーバーフロー対策
### バグ対策
* 品質確認
* 境界値テスト
* シンプルなコーディング
* ベストプラクティスを採用する（妄信しない）
### 暗号化と認証の利用
* 認証とパスワード管理
* アクセス制御
* 暗号の取り扱い
### エラー処理とログ
### データ保護
### 通信セキュリティ
### データベースセキュリティ
* データ型の制約
* データの制約
* CHECK制約
* データ関係の制約
* データバリデーション
### セッション管理
### ホワイトリストの採用
* デフォルトの拒否
### JSONセキュリティ対策
#### Webサーバーとの通信
	通常、JSONはXMLHttpRequestを利用して同じリソースでしかアクセスできない（同一オリジン）がJSONP（クロスオリジンリソース共有）という手法を使用すると別ドメインのものを利用できる
* JSONハイジャック
	+ 攻撃者がJSONデータを取得できる
	+ 対策として、JSONPを呼び出せないようにする
		- XMLHttpRequest 以外のリクエストはエラーにする(リクエスト先を固定化する)
		- Content+Type を "application/json; charset=utf+8" にする
		- "X+Content+Type+Options: nosniff" ヘッダーを追加する
#### ブラウザ上の操作
* eval インジェクション対策(出力対策)
	+ JSON.parse 関数を使用する
* クロスサイト・スクリプティング対策
* クリプトジャッキング
