## データ構造
1. 配列と文字列
	* Array
		+ メリット：インデックスを通して高速にアクセス可能。末尾のデータ挿入、削除は高速
		+ デメリット：データが大きい場合に大量のメモリを消費する。インデックス中間部分へのデータの挿入、削除が遅い 
2. 連結リスト
	* Linked List 
		+ メリット：データをどの部分であっても挿入、削除が容易なためリサイズが容易
		+ デメリット： リンクを辿ってアクセスするためデータのアクセスが遅い。次のデータのアドレスを保持するためデータのサイズがその分大きくなる
3. スタックとキュー
	* Stack
		+ メリット：データの取得は高速。再帰的な処理などと相性が良い
		+ デメリット：何も考えずに使うとStack Over Flowのようなメモリリークを起こす。中間のデータにはアクセス不可
	* Queue
		+ メリット：データの取得は高速。ファイルの入出力やWEBからのデータ入出力などと相性が良い
		+ デメリット：スタックと同様で何も考えずに使うとメモリリークを起こす。中間のデータにはアクセス不可
4. 木とグラフ
	* Binary Tree
		+ メリット：挿入、更新がLinked Listのように高速にでき、なおかつ検索も早い
		+ デメリット：深さが平衡していないと性能に悪影響を与える
	* Trie
		+ メリット：辞書など大量のデータパターンを高速に扱いたい場合に使用
		+ デメリット：メモリ消費量が多い
	* Graph 
		+ メリット：TreeやTrieでは扱えない循環型のデータを扱う時に使用。nodeごとのコストを割り振ることもできるので最適なルートやコストを求める問題にも適用可能
		+ デメリット： 複雑な為、扱うのが難しい

## 考え方とアルゴリズム
5. ビット操作
6. 数学と論理パズル
7. オブジェクト指向設計
8. 再帰と動的計画法
9. スケーラビリティとシステムデザイン
10. ソートと探索
	* ソート
		+ クイックソート：一般的に高速なアルゴリズムのため使用される機会が多い 
		+ マージソート：並列で処理が可能なため、メモリとCPUの並列数が豊富な場合に使用
		+ 挿入ソート：マージソートやクイックソートに比べ、データの状態に依存していないため安定的にソート可能。主に小さなデータやすでにほとんどソート済みのデータに使用 
		+ カウンティングソート：シンプルかつ高速なソート。メモリが豊富で扱うデータとマッチしていればこの手法が一番良い
	* 探索
		+ 深さ優先探索
		+ 幅優先探索
11. テスト
## 知識ベース
* C,C++
* Java
* データベース
* スレッドとロック
## Next
* 数学
* トポロジカルソート
* ダイクストラ法
* ハッシュテーブルの衝突処理
* ラビンカーブ文字列検索
* AVL木
* 赤黒木
* マップリデュース