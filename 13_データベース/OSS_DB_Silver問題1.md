#### データモデリングの一般的な手順はどれか
	データモデリングは、はじめに対象世界を抽象化して概念データモデルを作成します。
	次に概念データモデルを変換して論理データモデルを作成します。 
1. ［対象世界］→＜変換＞→［論理データモデル］→＜抽象化＞→［概念データモデル］
2. ［対象世界］→＜抽象化＞→［論理データモデル］→＜変換＞→［概念データモデル］
3. ［対象世界］→＜変換＞→［概念データモデル］→＜抽象化＞→［論理データモデル］
4. ［対象世界］→＜抽象化＞→［概念データモデル］→＜変換＞→［論理データモデル］

#### 関係モデルについて述べたもののうち、誤っているものはどれか。
	選択肢1,2,4は関係モデルについて述べたものです。
	関係と関係とを関連づけることでデータ構造を表現しますので選択肢3が誤っています。
	選択肢3は階層モデルの説明です。 
1. 行と列とからなる表構造でデータを表現する。
2. 一般的に複数の表構造によりモデルが定義される。
3. 親子関係を持たせることでデータ構造を表現する。
4. リレーショナルデータベースには関係モデルが使われる。

#### テーブルのインデックス作成、変更、削除などを行う命令が含まれるものはどれか。
	DML(Data Manipulation Language)はデータ操作言語で、データの参照や追加更新を行います。
	DDL(Data Definition Language)はデータ定義言語で、テーブルやインデックスの作成、変更、削除などを行いますので選択肢2が正解です。
	DCL(Data Control Language)はデータ制御言語で、権限の付与や剥奪、データ操作の確定やキャンセルなどを行います。
	DLL(Dynamic Link Library)はSQLではありません。 
1. DML
2. DLL
3. DDL
4. DCL

#### 概念データモデルから論理データモデルに変換する主な作業手順として正しいものはどれか。
	選択肢1は、概念データモデルの作成手順です。
	選択肢2は、概念データモデルから論理データモデルへの変換手順ですので正解です。
	選択肢3は、関係の候補キーと主キーの選択手順です。
	選択肢4は、正規化の手順です。 
1. 管理対象とするデータを抽出し、エンティティとして定義し、主な属性を明確にし、エンティティ間の関係を明確にする。
2. 多対多の関係を解消し、属性や属性のデータ型やサイズを明確にし、正規化を行う。
3. 候補キーを明確にし、候補キーの中から主キーを1つ選択する。
4. 繰返し項目を解消し、導出項目を削除し、部分関数従属を解消し、推移関数従属を解消する。

#### 関数従属について正しい説明はどれか。
	1.は「属性Yは属性Xに関数従属する」というのが正しく、記述が逆になっています。
	2.の完全関数従属とはXの真部分集合X'について、YがX'に関数従属しない場合のことをいうため誤りです。
	3.は正しいです。
	4.は推移関数従属の説明は正しいですが、第二正規形でではなく、第三正規形で取り除かれます。 
1. ある属性Xの値を決定すれば別の属性Yの値が一つに決まる場合、「属性Xは属性Yに関数従属する」という。
2. 属性Yが属性Xに完全関数従属する場合、Xの部分集合X'についてもYがX'に関数従属することになる。
3. 候補キーの一部の属性に候補キー以外の属性が関数従属することを部分関数従属という。
4. 推移関数従属とは、候補キーの属性Xが決まると属性Yが決まり、属性Yが決まると属性Zが決まる場合に、属性Zは属性Xに対して推移関数従属するという。第二正規形にする際に取り除かれる。

#### PostgreSQLのデータベースクラスタの説明に関して間違っているものはどれか。選択せよ。
	initdbコマンドによって作成されたデータベースの格納領域をデータベースクラスタと呼びます。
	データベースクラスタの実体は、ファイルシステム上の1つのディレクトリであり、initdbコマンドのオプションでディレクトリを指定するが出来ます。データベースクラスタを複数のマシンに分散することはできません。
	データベースクラスタの管理はデータベースサーバの1つのインスタンスを通して行います。
	複数のデータベースクラスタを作成した場合、それぞれのデータベースクラスタの管理は、異なるインスタンスを通して行います。 
1. データベースクラスタとPostgreSQLサーバは1対1で対応する。
2. データベースクラスタの実体はファイルシステム上のディレクトリである。
3. 1台のマシン上に複数のデータベースクラスタを作成することができる。
4. データベースクラスタは複数のマシン上に分散して配置することができる。
5. データベースクラスタは任意のディレクトリに作成することができる。

#### PostgreSQLのデータベースクラスタ($PGDATA)の主なディレクトリとファイルの記述として、間違っているものはどれか。選択せよ。
	postgresql.confは、PostgreSQLのパラメータを設定するファイルです。なお、クライアントの認証方法はpg_hba.confファイルで設定します。
1. baseディレクトリには、データベースのデータが格納される。
2. pg_xlogディレクトリには、トランザクションログ(WAL)が格納される。
3. postgresql.confファイルには、クライアントの認証方法が設定される。
4. globalディレクトリには、ユーザー情報などデータベース間で共通のデータが格納される。

#### PostgreSQLにおけるデータベースの説明として間違っているものはどれか。選択せよ。
	initdbコマンドはデータベースクラスタの作成を行うためのコマンドであり、テンプレートおよびPostgresデータベースのみ作成されます。任意の名称のデータベースは作成できないため誤りです。
	データベース作成および初期化は、createdbコマンド、またはSQLのCREATE DATABASEを実行することで行います。
	作成したデータベースの実体は、$PGDATA/base以下のディレクトリとして作成され、テーブルやインデックスのデータはデータベース毎に格納されます。 
1. データベースは、テーブルやインデックスなどのデータベースオブジェクトの集合である。
2. データベースの実体はファイルシステム上のディレクトリである。
3. データベースクラスタには複数のデータベースを作成することができる。
4. initdbコマンドにより任意の名称のデータベースを作成し、データベースを利用できる。

#### PostgreSQLのデータベースクラスタ作成時に定義されるテンプレートデータベース「template0」、「template1」について適切な記述はどれか。選択せよ。
	データベースクラスタ作成直後はtemplate0とtemplate1は同じ内容のテンプレートデータベースです。
	デフォルトでは、template1が新しいデータベースのテンプレートとして使われます。template1にはオブジェクトを追加登録することができるため、多くのデータベースで利用するオブジェクトをtemplate1に事前登録することでデータベース作成後の手順を簡略化することができます。
	template0にはオブジェクトの追加登録はできず、template1に追加登録されたオブジェクトも反映されません。template1に追加登録されたオブジェクトを利用したくない場合、template0を指定してデータベースを作成します。

* 次の例ではテンプレートデータベースであるtemplate0を指定してデータベースtest1を作成しています。
```
CREATE DATABASE test1 TEMPLATE template0;
```
1. データベースクラスタ作成直後はtemplate0とtemplate1は同じ内容のテンプレートデータベースである。
2. template1にオブジェクトが追加登録されるたびにtemplate0にも同じオブジェクトが追加登録される。
3. 指定しない限り、template0が新しいデータベースのテンプレートとして使われる。
4. template0にデータベースオブジェクトの登録などの内容の変更が可能である。

#### PostgreSQLにおけるロケールに関する記述について、適切なものはどれか。選択せよ。
	データベースへのロケール設定は、必須ではありません。参考までに、日本（日本語）ではロケールは無効にすることが推奨されています。
	ロケールはクライアント側で使用されているロケールと異なるロケールをデータベースに設定でき、データベース単位でロケールを設定することもできます。
	データベースのデフォルトのロケールはinitdbで指定した値になります。
	initdbコマンドで指定したロケールと異なるロケールのデータベースを作成するには、template0をテンプレートに指定した上で、データベース作成時にロケールを指定します。

* 次の例ではPostgreSQLの標準ツールであるcreatedbを利用して、ロケールに日本語が設定されたデータベースtest1を作成しています。
```
createdb test1 --locale=japanese --template=template0
```
1. データベースに、ロケールは必ず設定しなければならない。
2. initdbコマンドで指定したロケールと異なるロケールのデータベースを作成することはできない。
3. ロケールはデータベース単位で指定することができる。
4. クライアント側で使用されているロケールと同じロケールをデータベースに設定する必要がある。

#### PostgreSQLにおけるエンコーディングの設定では、データベースとクライアントについて個別のエンコーディングを指定することが出来る。次のうち指定できない文字セットの組み合わせを選択せよ。
	PostgreSQLでは、データベースエンコーディングにSJISを指定することは出来ません。
	文字セットとしてSJISを利用したい場合には、データベースエンコーディングにUTF-8またはEUC-JPを指定し、クライアントエンコーディングにSJISを指定します。
	データベースエンコーディングと異なるクライアントエンコーディングを用いる場合には、クライアントエンコーディングをデータベースに通知する必要が有ります。
	主な方法を以下に示します。

* psqlで\encodingコマンドを利用する。
* libpqが提供する関数を利用する。
* SQLコマンドの”SET CLIENT_ENCODING TO 'value'”を利用する。
* クライアントの環境でPGCLIENTENCODING環境変数を設定する。
* PostgreSQLのパラメータを設定するファイル(postgresql.conf)にclient_encodingを設定する。 

1. データベースエンコーディングがSJIS。
	クライアントエンコーディングがSJIS。
2. データベースエンコーディングがUTF-8。
	クライアントエンコーディングがSJIS。
3. データベースエンコーディングがEUC-JP。
	クライアントエンコーディングがSJIS。
4. データベースエンコーディングがUTF-8。
	クライアントエンコーディングがEUC-JP。
5. データベースエンコーディングがEUC-JP。
	クライアントエンコーディングがUTF-8。

#### スマートシャットダウン(pg_ctl stop -m smart)の動作について正しい記述はどれか。選択せよ。
	スマートシャットダウンは既存の接続が全て切断されるのを待ってから正常終了をします。
	ちなみに、3は高速シャットダウン(pg_ctl stop -m fast)、4は即時シャットダウン(pg_ctl stop -m immediate)の動作になります。 

1. 既に接続されている接続が全て切断されるのを待った後、正常終了する。
2. 既に接続されている接続が全て切断されるのを待つが、実行中のトランザクションは全てロールバックされる。
3. 既に接続されている接続を強制的に切断し、実行中のトランザクションは全てロールバックされる。 
4. クリーンアップ処理を行なわずに緊急停止する(PostgreSQLがクラッシュしたのと同じ状態になる)。 

#### pg_ctlについて適切な記述はどれか。選択せよ。
	pg_ctl initdbとinitdbは同じ処理内容です。pg_ctl initdbで主に使用するオプションには-D(--pgdata=)と-oがあります。-Dではデータベースクラスタを指定し、-oでは内部的に呼び出すinitdbに渡すオプションが指定出来ます。 

1. postgresql.confの設定値を変更した後にpg_ctl reload を実行すると全ての変更箇所が反映される。
2. pg_ctl startにおいて-Wオプションをつけると、PostgreSQLが起動完了するまで待つ。
3. pg_ctlはPostgreSQLが実際稼働していないホストからのリモート実行が可能であり、実行するユーザーはPostgreSQLの管理ユーザーでなければならない。
4. pg_ctl initdbとinitdbの処理内容は同じであり、どちらをデータベースクラスタの作成に使っても問題ない。

#### dropdbを使用して、スーパユーザーuser1で、ホストhost1、ポート10000で動作しているデータベースクラスタからdb1データベースを削除する。このとき正しいコマンドを示すのはどれか。選択せよ。
	dropdbのオプションは以下になります。
	```
	dropdb [option] dbname
	```
	dbname: 削除するデータベース名を指定

	[option]
	-h: ホスト名を指定
	-p: ポート番号を指定
	-U: ユーザー名を指定
	-W: パスワードの入力を強制
	-e: dropdbが生成し、バックエンドに送信する問い合わせを表示
	-q: メッセージを表示しない
	-i: dropdbを実行する前に確認を促す

1. $ dropdb user1 host1 10000 db1
2. $ dropdb -U user1 host1:10000:db1
3. $ dropdb -U user1 -p 10000 host1:db1
4. $ dropdb -U user1 -p 10000 -h host1 db1
5. $ dropdb -U user1 -p 10000 -h host1 -D db1

#### createdb、dropdbコマンドについて適切な記述はどれか。選択せよ。
	2については、createdbコマンドに-Tオプションの指定がないとtemplate1がテンプレートデータベースとなります。
	3については、データベースを削除していいかを確認するにはdropuserと同様に-iオプションが必要です。
	4については、dropdbコマンドを実行出来るのは、データベースのスーパーユーザーまたはデータベースの所有者のみです。 

1. createdbコマンドでデータベースを作成するとき、「-O」オプションで所有者を指定した場合は、その所有者がスーパーユーザー権限やデータベース作成権限を持っていなくても、作成したデータベースの削除が可能となる。
2. createdbコマンドに-Tオプションをつけるとテンプレートデータベースの指定が出来る。指定がないとtemplate0がテンプレートデータベースとなる。
3. dropdbコマンドはデフォルトでデータベースを削除してよいかの確認を削除前に取るようになっている。
4. dropdbコマンドを実行出来るのは、データベースのスーパーユーザーまたはデータベース作成権限を持っているユーザーのみである。

#### PostgreSQLにおいての手続き言語の登録と削除について適切な記述はどれか。選択せよ。
	手続き言語は手続き言語を使用するデータベースに登録されている必要があり、登録にはcreatelangコマンドを使用します。反対に登録されている手続き言語を削除する場合はdroplangコマンドを使用します。

1. 手続き言語は手続き言語を使用するデータベースに登録されている必要があり、登録にはcreatelangコマンドを使用する。
2. 手続き言語を登録出来るのはスーパーユーザーのみである。
3. 手続き言語の登録と削除はデータベース単位で指定することは出来ない。
4. テンプレートデータベースに手続き言語を登録した場合でも、以降そのテンプレートデータベースを利用して新しくデータベースを作成した時に自動的に手続き言語が登録されることはない。

#### psqlについて正しい記述はどれか。選択せよ。
	psqlではSQLコマンドの終わりをセミコロンで判断する為、SQLコマンドは1行が長い場合改行で分けて記述が出来ますが、メタコマンドは必ず1行で入力する必要があります。

1. psqlでデータベースに接続する際のデフォルトのユーザー名、データベース名はpostgresである。
2. psqlのメタコマンドの\dSは、シーケンス一覧を表示する。
3. psqlの-Dオプションでデータベースを指定して接続、-Uオプションで接続するユーザー名を指定することが出来る。
4. psqlではSQLコマンドの終わりをセミコロンで判断するが、メタコマンドは改行で終わりを判断する。

#### log_rotation_ageの指定として1日を設定する場合、誤っているものはどれか。選択せよ。
	時間の設定値には次のような単位を指定できます。
* ms：ミリ秒
* s：秒
* min：分
* h：時間
* d：日
	単位を省略した場合、log_rotation_ageは'分'として扱われます。 
1. 1d
2. 24h
3. 1440m
4. 1440
5. 86400s

#### listen_addressesの説明で適切なものはどれか。選択せよ。
	listen_addressesには、クライアントからの接続を監視するPostgreSQL側のIPアドレスもしくはホスト名を指定します。複数のアドレスを指定する場合はカンマ(,)区切って指定します。また、アスタリスク(*)を指定した場合は、PostgreSQL側で利用可能な全てのアドレスに対して接続を監視します。
	設定の変更にはPostgreSQLの再起動が必要です。
	クライアントのアクセス権限はph_hba.conf で設定します。 

1. 接続予定のクライアントのIPアドレスを指定することで、該当のクライアントの接続を監視する。
2. 複数のIPアドレスを指定することはできない。
3. 変更内容はpg_ctl reloadで有効にすることができる。
4. '*'を指定することで、利用可能な全てのIPアドレスの接続を監視する。
5. 接続予定のクライアントのホスト名をカンマ区切りで複数指定することで、該当のクライアントの接続を監視する。

#### log_destinationの設定で誤っているものはどれか。選択せよ。
	log_destinationは、サーバログの出力先を設定します。出力先は
* stderr
* csvlog
* syslog
	の3種類の指定が可能で、カンマ(,)区切りで複数設定することができます。
	csvlogを指定する場合は、logging_collectorをonにする必要があります。 

1. syslog
2. stderr
3. syslog, stderr
4. csvlog
5. file

#### 起動中のPostgreSQLに、max_connectionsの設定を反映する方法のうち、適切なものはどれか。選択せよ。
	max_connectionsの設定変更を反映するためには、PostgreSQLの再起動が必要であり、以下のどちらかを行う必要があります。
* pg_ctl stop および pg_ctl start
* pg_ctl restart
	同様に設定反映のためにPostgreSQLの再起動が必要なものは、postgresql.confに'# (change requires restart)' というコメントが付いています。 

1. pg_ctl reloadを実行する。
2. pg_ctl stopを実行する。
3. pg_ctl restartを実行する。
4. pg_ctl statusを実行する。
5. pg_ctl startを実行する。

#### pg_hba.confのCIDRアドレス指定で誤っているものはどれか。選択せよ。
	pg_hba.confのCIDRアドレス部分には、クライアントが所属するサブネットのアドレスをCIDR形式で設定します。また、CIDR形式の代替手段として、IPアドレスとサブネットマスクの形式で設定することも可能ですが、ドメイン名やホスト名は指定できません。 

1. 192.168.16.0/24
2. 192.168.16.8/32
3. 192.168.16.0 255.255.255.0
4. localhost
5. ::1/128

#### publicスキーマと新しいスキーマ(new_schema)をsearch_pathに登録するSET文はどれか。選択せよ。
	SET文は、PostgreSQL起動中に設定値を変更できます。SET文により変更された設定値は、そのSET文を実行したセッションのみに効果があります。また、設定値としてDEFAULTを指定することでデフォルト値に戻すことができます。 

1. SET search_path ADD public, new_schema
2. SET search_path TO public, new_schema
3. SET public, new_shcmea TO search_path
4. SET public, new_shcmea ADD search_path
5. SET search_path = DEFAULT

#### PostgreSQLのデータベースクラスタ全体をバックアップ(スクリプトファイルへ抽出)する際に使用するコマンドはどれか。選択せよ。
	PostgreSQL全体をバックアップするコマンドは、pg_dumpallコマンドを用います。 

1. pg_dump --full
2. pg_dumpall
3. pg_dumpfull
4. psql dumpall
5. pg_dump all

#### pg_dump/pg_dumpallコマンドによるバックアップに関して、テキスト形式にならないコマンドはどれか。選択せよ。
	pg_dumpコマンドの-Fオプションにtを指定すると、tar形式のバックアップを取得します。

1. pg_dump -Ft
2. pg_dump
3. pg_dump -Fp
4. pg_dumpall

#### pg_dump/pg_dumpallコマンドで取得したテキスト形式のバックアップファイル(bkup.dmp)をリストアする際に使用するコマンドはどれか。選択せよ。
	テキスト形式のバックアップをリストアする際には、psqlコマンドを利用します。その際、-fオプションで対象のバックアップファイルを指定します。 
	
1. psql bkup.dmp
2. pg_restore -Fp bkup.dmp
3. psql -Fp bkup.dmp
4. pg_restore -f bkup.dmp
5. psql -f bkup.dmp

#### ディレクトリコピーによるバックアップ(コールドバックアップ)に関して正しい記述はどれか。選択せよ。
	コールドバックアップではデータベースクラスタ全体を取得する必要があります。 

1. テーブル単位で取得する。
2. データベースクラスタ単位で取得する。
3. データベース単位で取得する。
4. スキーマ単位で取得する。

#### psqlの\copyコマンドの説明に関して、正しいものはどれか。選択せよ。
	\copyコマンドは、クライアント側のファイルとサーバ側のテーブル間でデータのコピーを行うコマンドです。

1. サーバ側のファイルをテーブルにコピーする。
2. ファイル名は絶対パスのみ指定可能である。
3. スーパーユーザーで実行する必要がある。
4. クライアントとサーバ間でデータの送受信がなされる。

#### 自動バキュームについて誤った記述を選択せよ。
	自動バキューム機能の設定はpostgresql.confで設定します。
	自動バキュームの実行には自動バキュームデーモンの起動有無を表すパラメータautovacuumと統計情報の収集有無を表すパラメータtrack_countsがいずれも有効になっている必要があります。
	PostgreSQL 9.0ではどちらのパラメータもデフォルトで有効となっています。

	自動バキュームは、それぞれのテーブルの更新量が閾値以上になった時にテーブル単位でVACUUMとANALYZEが自動実行されます。 

1. 自動バキューム機能は、postgresql.confで設定する。
2. 自動バキューム機能をONにした場合、一定間隔でVACUUMとANALYZEを実行する。
3. PostgreSQL9.0では自動バキューム機能の設定値はデフォルトで有効となっている。
4. 自動バキューム機能を動作させるにはpostgresql.confのautovacuumパラメータ,track_countsパラメータのいずれも有効になっている必要がある。

#### データベースのユーザー管理について、適切な記述を選択せよ。
	CREATE USER文、あるいはALTER USER文ではVALID UNTILオプションを使ってパスワードの有効期限を設定することができます。 
1. ユーザーに設定する権限はあとから変更することができないので慎重にユーザーを作成する必要がある。
2. DROP USER文でユーザーの削除を行うことができるのは、スーパーユーザー権限を持ったユーザーとDROP USER権限を持ったユーザーのみである。
3. 以下のSQL文を実行してユーザーを作成した。
```
CREATE USER user1 WITH PASSWORD 'password';
```
作成したユーザーuser1は、ALTER USER文でログイン権限を付与するまでPostgreSQLにログインできない。
4. ユーザーを作成する際、対象ユーザーのパスワード有効期限を設定することができる。

#### 次に挙げるSQLのうち、現在のデータベース名を取得するものでないものを選択せよ。
	現在のデータベース名の情報は、システム情報取得関数のcurrent_catalog,current_database()と情報スキーマのinformation_schema_catalog_nameで取得できます。
	システムカタログpg_databaseは現在のデータベースの情報ではなく、使用可能なデータベースの情報が格納されています。 

1. SELECT datname FROM pg_database;
2. SELECT * FROM information_schema.information_schema_catalog_name;
3. SELECT current_catalog;
4. SELECT current_database();

#### 次に上げる情報のうち、情報スキーマから取得できないものを選択せよ。
	情報スキーマは、現在のデータベースで定義されたオブジェクトについての情報を持つビューの集合から構成され、標準SQLで定義されています。

	PostgreSQL固有の機能についての情報は情報スキーマには含まれていません。PostgreSQL固有の情報はシステムカタログやPostgreSQL独自関数により取得できます。 

1. データベース上に定義されているユーザー
2. PostgreSQLのバージョン
3. データベース上に定義されているテーブル
4. データベース上に定義されたテーブルへのアクセス権限

#### \dpコマンドでテーブルの権限を確認したところ、NameがtesttableのレコードのAccess privilegesが以下のような値だった。
```
test=arwdDxt/test+
test2=rwD/test
```
このときの説明として正しいものを選択せよ。
	\dpコマンド、もしくは\zコマンドを使うとテーブルに付与された権限を確認することができます。
	\dpコマンドで表示される権限情報の書式は以下の通りです。
```
<ユーザー名>=<権限情報>/権限付与したユーザー
```
ユーザー名の部分が空白で、=からはじまっている場合、すべてのユーザー(PUBLIC)へ付与された権限内容を表します。
権限情報の内容は以下の通りです。
　r：SELECT権限
　w：UPDATE権限
　a：INSERT権限
　d：DELETE権限
　D：TRUNCATE権限
　x：外部キー制約権限
　t：TRIGGER権限 

1. ユーザーtest2はテーブルtesttableに対してINSERT権限を持つ。
2. ユーザーtest2はテーブルtesttableに対してCOPY TOを使用することができない。
3. ユーザーtest2は、テーブルtesttableに対するSELECT権限を他のユーザーtest3に付与することができる。
4. このような権限を付与するためのGRANT文は以下の通りである。
```
GRANT SELECT,UPDATE,TRUNCATE ON testtable TO test2;
```
5. このような権限を付与するためのGRANT文は以下の通りである。
```
GRANT SELECT,UPDATE,DELETE ON testtable TO test2;
```

#### テーブルに対する権限付与について、誤っている説明を選択せよ。
	テーブルに対するアクセス権限はGRANT文により付与し、REVOKE文により剥奪します。
	すべてのユーザーに対して権限を付与する場合は、ユーザー名をpublicに指定します。
	SQLコマンドと権限の関係は、COPY TOはSELECT権限に、COPY FROMはINSERT権限に包含されます。 

1. GRANT文によってテーブルの権限を付与しないと、テーブルを作成したユーザー以外からの情報の更新ができない。
2. 権限はテーブル単位以外に列単位でも設定できる。
3. すべてのユーザーがテーブルtab1を参照できるようにするための権限付与SQLは以下の通りである。
```
GRANT SELECT ON tab1 TO public;
```
4. ユーザーusr1へテーブルtab1に対するCOPY TOの使用を許可するための権限付与SQLは以下の通りである。
```
GRANT COPY TO ON tab1 TO usr1;
```

#### 集合演算子であるUNION、EXCEPT、INTERSECTの処理には優先順位が定められている。次の選択肢のうち、正しいものはどれか。
	標準SQLではUNIONとEXCEPTに対して、INTERSECTのほうが先に実行されるよう定められています。
	UNIONとEXCEPTの処理の優先順位は同じです。 

1. UNION < EXCEPT
	EXCEPT < INTERSECT
2. UNION = EXCEPT
	EXCEPT < INTERSECT
3. UNION = EXCEPT
	UNION > INTERSECT
4. UNION > EXCEPT
	EXCEPT > INTERSECT

#### 以下のうち、boolean型の表現として使用できないものはどれか。
	boolean型の指定として整数の1と0は使用できません。指定する場合は'1','0'と文字列として指定する必要があります。 

1. 't'
2. 'y'
3. 'on'
4. 1

#### 以下(A)～(D)のうち、ALTER TABLEで行えないものはどれか。

(A)テーブル名の変更
(B)列名の変更
(C)列の削除
(D)列のデータ型の変更
 
1. (A)テーブル名の変更
2. (B)列名の変更
3. (C)列の削除
4. (D)列のデータ型の変更
5. すべて可能

#### 以下のようなテーブルnumberが与えられている。
```
CREATE TABLE number ( code VARCHAR(10) , no INTEGER);
INSERT INTO number(code , no) VALUES('one' , 1);
INSERT INTO number(code , no) VALUES('one' , 2);
INSERT INTO number(code , no) VALUES('two' , 1);
INSERT INTO number(code , no) VALUES('two' , 2);
INSERT INTO number(code , no) VALUES('two' , 3);
INSERT INTO number(code , no) VALUES('three' , 1);
INSERT INTO number(code , no) VALUES('three' , 2);
INSERT INTO number(code) VALUES('four');
```
このとき、以下のSQLの出力結果として適切なものはどれか。選択せよ。
```
SELECT * FROM number WHERE no > (SELECT MIN(no) FROM number WHERE code = 'five');
```
 
1. 7行の検索結果が返る。
2. 8行の検索結果が返る。
3. 0行の検索結果が返る。
4. シンタックスエラーとなる。

#### トランザクションのもつ特性について誤った記述はどれか。選択せよ。
* Correctness(正当性)は、ACID属性には含まれていません。
* トランザクションのACID特性は、Atomicity(原子性)、Consistency(整合性)、Isolation(分離性)、Durability（持続性）の頭文字をとって名づけられました。
* Consistency(整合性)は、トランザクションの開始と終了時には、データベースは整合性を保った状態となっていることを保証します。 

1. トランザクションは実行が完了するか、あるいはまったく実行されないかのどちらかとなることを、トランザクションのAtomicity(原子性)という。
2. トランザクションのACID特性は、Atomicity(原子性)、Correctness(正当性)、Isolation(分離性)、Durability（持続性）の頭文字をとって名づけられた。
3. トランザクションは別のトランザクションによる処理の影響を受けないことを、トランザクションのIsolation(分離性)という。
4. トランザクションにより変更されたデータは確実に保持されることを、トランザクションのDurability(持続性)という。

#### SAVEPOINTの記述として正しいものはどれか。選択せよ。
* トランザクション内で同じセーブポイント名を設定した場合、一時的に古い方を上書きします。
* SAVEPOINT sp1; の場所へ戻るときのコマンドは ROLLBACK TO sp1; です。
* COMMITでトランザクション処理を確定した後は、COMMIT前の状態に戻ることはできません。
* トランザクション内でエラーが発生した場合、設定した任意のSAVEPOINTまで戻って処理を続けることが可能です。 
1. SAVEPOINT sp1; で作成したポイントへ戻りたいときは、ROLLBACK sp1; を発行する。
2. COMMIT発行後もCOMMIT発行前のSAVEPOINTへROLLBACKすることができる。
3. 1つのトランザクションの中に、同じ名前のSAVEPOINTを設定することができる。
4. トランザクション内でエラーが起こった場合、それまでに設定したSAVEPOINTは無効になる。

#### 
#### 
