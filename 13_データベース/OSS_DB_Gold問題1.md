# 参照
* [サンプル問題](https://oss-db.jp/sample)
* [内部構造から学ぶPostgreSQL 設計・運用計画の鉄則]()
    + NTTテクノクロス株式会社　河原 翔
    + NTTテクノクロス株式会社　勝俣 智成
    + NTTテクノクロス株式会社　佐伯 昌樹
    + NTTテクノクロス株式会社　原田 登志
* 株式会社メトロシステムズ　岡野 慎也
* 株式会社デージーネット OSS研究室 奥原 章太
* 株式会社デージーネット OSS研究室 大野 公善

# OSS-DB Gold問題
## １．運用管理（30％）
### Q．crypt関数の意味として、正しいものは次のうちどれか。
* [詳細 []](https://oss-db.jp/sample/gold_management_01/22_190731)
1. 対称鍵を指定して、データを暗号化する
2. データのバイナリハッシュを計算する
3. パスワードのハッシュ処理を行う
4. データのハッシュ化MACを計算する
5. パスワードハッシュ時に使用するランダムなソルト文字列を新規に作成する

### Q．バックアップに関して正しいものをすべて選択しなさい。
* [詳細 []](https://oss-db.jp/sample/gold_management_01/16_170313)
1. 通常はフルバックアップを取得するよりも、pg_basebackupによって更新差分を取得する方が処理時間は短い。
2. recovery_target_timelineをデフォルト値で使用すると、ベースバックアップが取得された際のタイムラインへ回復する。
3. pg_dumpコマンドによってpsqlコマンドでリストア可能な形式 として出力したバックアップファイルには、データベースを作成する SQLコマンドが含まれる場合がある。
4. pg_dumpコマンドも、pg_restoreコマンドも並列実行することが可能であり、複数のデータベースのバックアップ・リストア処理を行う際は高速化が図れる。
5. pg_restoreコマンドで--encodingオプションを使用すると、sjisで作成したダンプファイルをUTF8でリストアすることができる。

### Q．pg_basebackupコマンドに関する説明として、適切でないものを2つ選びなさい。
* [詳細 []](https://oss-db.jp/sample/gold_management_01/11_150123)
1. 別サーバで動作しているPostgreSQLデータベースクラスタのベースバックアップを取得できる
2. pg_basebackupコマンドの実行前にpg_start_backupコマンドを実行する必要がある
3. fetch方式の場合、max_wal_sendersパラメータを少なくとも1以上に設定する必要がある
4. オプションを明示的に指定しないで実行した場合は、WALはバックアップに含まれない
5. テーブル空間が追加で作成されている場合は、テーブル空間内のデータはバックアップに含まれない

### Q．VACUUMに関して正しいものを全て選択しなさい。
* [詳細 []](https://oss-db.jp/sample/gold_management_01/10_141027)
1. FULLオプションを付加すると、データベース全体の不要領域が回収される。
2. VERBOSEオプションを付加すると、VACUUM処理の詳細な情報を取得することができる。
3. AUTOオプションを付加すると、autovacuumの設定を用いてVACUUMが行われる。
4. ANALYZEオプションを付加すると、統計情報の更新も行われる。
5. 一つのVACUUMコマンドに複数のテーブルを指定して実行することができる。

### Q．VACUUMに関して正しいものを全て選択しなさい。
* [詳細 []](https://oss-db.jp/sample/gold_management_01/08_140702)
1. VACUUMを実行するユーザが対象テーブルに対するVACUUMの実行権限を持っていない場合はエラーとなる。
2. トランザクションブロック内でVACUUMを実施すれば、ROLLBACKによって処理を取り消すことができる。
3. オプションが指定されていない通常のVACUUMでも、不要領域をOSに返還することがある。
4. 多数の行を追加または削除した場合は、VACUUM ANALYZEを実施すべきである。

### Q．ANALYZEに関して正しいものを全て選択しなさい。
* [詳細 []](https://oss-db.jp/sample/gold_management_01/07_140307)
1. 整列されたデータを昇順にロードした場合、ANALYZEを実施しなくとも最適なプランが作成される。
2. 自動バキュームデーモンがANALYZEを実施する場合がある。
3. default_statistics_targetの値を大きくすると、ANALYZEの所要時間は短くなるがプランナの予測の品質は低下する。
4. 対象とするテーブルへのSHARE UPDATE EXCLUSIVEロックが取得される。
5. PostgreSQLのANALYZE文は、標準SQLに準拠している。

### Q．2台のサーバ(プライマリサーバ、スタンバイサーバ)でストリーミングレプリケーションを行い、スタンバイサーバをホットスタンバイとして運用する。 この環境を構築する際に各サーバで設定するパラメータとして誤っているものを1つ選びなさい。
* [詳細 []](https://oss-db.jp/sample/gold_management_01/06_130619)
1. プライマリサーバのpg_hba.confに、データベースフィールドを"replication"と指定した項目を設定する
2. プライマリサーバのpostgresql.confに、"wal_level = hot_standby"を設定する
3. スタンバイサーバのpostgresql.confに、"hot_standby = on"を設定する
4. スタンバイサーバのpostgresql.confに、"standby_mode = 'on'"を設定する
5. スタンバイサーバのrecovery.confの"primary_conninfo"に、プライマリサーバへの接続情報(libpq接続文字列)を設定する

### Q．データベースクラスタ配下の各サブディレクトリに保有されるデータの説明として、適切ではないものを1つ選びなさい。
* [詳細 []](https://oss-db.jp/sample/gold_management_01/05_130510)
1. globalディレクトリにはデータベースクラスタ全体で共有するテーブルが保有される。
2. pg_tblspcディレクトリにはテーブル空間により管理されるテーブルが保有される。
3. pg_xactディレクトリにはトランザクションのコミット状態のデータが保有される。
4. pg_walディレクトリにはWALファイルが保有される。
5. pg_stat_tmpディレクトリには統計情報コレクタがバックエンドプロセスと必要な情報をやり取りするための一時ファイルが格納される。

### Q．以下のSQL文でインデックスを定義し、100万行を挿入する。ここで、team_idのデータ型はINTEGER、birthdayのデータ型はDATE、いずれもNOT NULL制約が付いているものとする。インデックスのファイルサイズ見積りとして最も適切なものを1つ選びなさい。なお、1ブロックは8192バイトとし、FILLFACTORは90%とする。
* [詳細 []](https://oss-db.jp/sample/gold_management_01/04_130401)
```
CREATE INDEX member_index ON member_table (team_id, birthday);
```
1. 9メガバイト
2. 13メガバイト
3. 19メガバイト
4. 23メガバイト
5. 29メガバイト

### Q．PostgreSQL のプロセス構造について、適切なものをすべて選びなさい。
* [詳細 []](https://oss-db.jp/sample/gold_management_01/02_111130)
1. データベースに接続するクライアント一つ一つについて、別々のサーバプロセスが起動する。
2. データベースクラスタ内のそれぞれのデータベースについて、別々のサーバプロセスが起動する。
3. WAL ライタ、自動バキュームランチャ、統計情報コレクタなどいくつかのプロセスが動作しているが、いずれも postgres という同一の実行ファイルから作られるプロセスである。
4. クライアントが接続していないときは、通常は postmaster というプロセスだけが動作している。
5. データベースクラスタ1つに対して、postmaster というプロセスが1つ動作している。

### Q．以下のSQL分でテーブルを定義し、50万行を挿入する。テーブルのファイルサイズ見積りとして最も適切なものを1つ選びなさい。1ブロックは8192バイトとし、インデックスのファイルサイズは含めないものとする。
```
CREATE TABLE registration (
  id BIGINT PRIMARY KEY,
  reg_event INTEGER NOT NULL,
  reg_client INTEGER NOT NULL,
  reg_date TIMESTAMP NOT NULL
);
```
1. 5メガバイト
2. 15メガバイト
3. 25メガバイト
4. 40メガバイト
5. 60メガバイト


## ２．性能監視（30％）
### Q．
### Q．

## ３．パフォーマンスチューニング（20％）
### Q．シーケンシャルスキャンのみ行われていた選択クエリ高速化のためにインデックスを付与したが、その後のクエリが逆に遅くなってしまった。推測できる原因として適切なものを2つ選びなさい。
* 1. random_page_costの値が適切な値より小さく設定されているため
* 2. maintenance_work_memの値が適切な値より小さく設定されているため
* 3. effetive_cache_sizeの値が適切な値より小さく設定されているため
* 4. seq_page_costの値が適切な値より小さく設定されているため
* 5. 統計情報の精度が低く、適切な実行計画が作成されていないため
<details><div>
    A．1,5

* インデックスを付与したことによりクエリが遅くなったということは、「オプティマイザはインデックスを利用したほうがクエリが高速化すると判断したが、その判断に誤りがあった」ということになる。
* 1. 「random_page_costの値が適切な値より小さい」場合、「オプティマイザは実際よりもインデックスアクセスが高速である」と判断することになるため、適切。
* 2. maintenance_work_memの値は、コスト計算とは無関係であるため、不適切
* 3. 「effetive_cache_sizeの値が適切な値より小さい」場合は、「オプティマイザは実際よりもインデックスアクセスが低速である」と判断することになるため、不適切。
* 4. 「seq_page_costの値が適切な値より小さい」場合は、「オプティマイザは実際よりもシーケンシャルアクセスが高速である」と判断することになるため、不適切。
* 5. 統計情報の精度が低異場合は、適切な実行計画が作成されないため、適切
</div></details>


### Q．CLUSTERコマンドに関する説明として適切ではないものを２つ選びなさい。
* 1. CLUSTERコマンドの実行後は、該当のインデックスを利用した検索クエリの性能が向上する可能性がある
* 2. CLUSTERコマンドの実行後は、該当のテーブル更新時にインデックス情報に基づいた処理が行われるため、更新性能が低下する可能性がある
* 3. 単一のテーブルに対して複数のインデックスが存在する場合、それぞれのインデックスに対して同時に最適化させるためのCLUSTERコマンドを発行することができない
* 4. CLUSTERコマンドはACCESS EXCLUSIVEロックを獲得するため、クラスタ化が終われまで、そのテーブルに対する読み込みが待機される
* 5. correlationの値が負数の場合は相関率が低いため、CLUSTERコマンドの実行を検討すべきである
<details>A．2,5</details>

### Q．ロックに関する以下の記述で適切ではないものを２つ選びなさい。
* 1. pg_locksビューのcurrent_query列には、ロックを保持しているクエリが表示される
* 2. pg_locksビューには行ロックを保持しているトランザクションは表示されない
* 3. deadlock_timeoutの値を大きくすると、デッドロックが検出されるまでの時間が長くなる
* 4. deadlock_timeoutの値を大きくすると、デッドロックの誤検知の発生確率が高くなる
* 5. トランザクションが並列実行される状態において、パラメータチューニングによりデッドロックの発生を防止する方法はない


## ４．障害対応（20％）
