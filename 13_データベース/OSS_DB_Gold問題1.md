## パフォーマンスチューニング（20％）
### 01 シーケンシャルスキャンのみ行われていた選択クエリ高速化のためにインデックスを付与したが、その後のクエリが逆に遅くなってしまった。推測できる原因として適切なものを2つ選びなさい。
* 1. random_page_costの値が適切な値より小さく設定されているため
* 2. maintenance_work_memの値が適切な値より小さく設定されているため
* 3. effetive_cache_sizeの値が適切な値より小さく設定されているため
* 4. seq_page_costの値が適切な値より小さく設定されているため
* 5. 統計情報の精度が低く、適切な実行計画が作成されていないため
#### 1,5
    インデックスを付与したことによりクエリが遅くなったということは、「オプティマイザはインデックスを利用したほうがクエリが高速化すると判断したが、その判断に誤りがあった」ということになる。
* 1. 「random_page_costの値が適切な値より小さい」場合、「オプティマイザは実際よりもインデックスアクセスが高速である」と判断することになるため、適切。
* 2. maintenance_work_memの値は、コスト計算とは無関係であるため、不適切
* 3. 「effetive_cache_sizeの値が適切な値より小さい」場合は、「オプティマイザは実際よりもインデックスアクセスが低速である」と判断することになるため、不適切。
* 4. 「seq_page_costの値が適切な値より小さい」場合は、「オプティマイザは実際よりもシーケンシャルアクセスが高速である」と判断することになるため、不適切。
* 5. 統計情報の精度が低異場合は、適切な実行計画が作成されないため、適切


### 02 CLUSTERコマンドに関する説明として適切ではないものを２つ選びなさい。
* 1. CLUSTERコマンドの実行後は、該当のインデックスを利用した検索クエリの性能が向上する可能性がある
* 2. CLUSTERコマンドの実行後は、該当のテーブル更新時にインデックス情報に基づいた処理が行われるため、更新性能が低下する可能性がある
* 3. 単一のテーブルに対して複数のインデックスが存在する場合、それぞれのインデックスに対して同時に最適化させるためのCLUSTERコマンドを発行することができない
* 4. CLUSTERコマンドはACCESS EXCLUSIVEロックを獲得するため、クラスタ化が終われまで、そのテーブルに対する読み込みが待機される
* 5. correlationの値が負数の場合は相関率が低いため、CLUSTERコマンドの実行を検討すべきである
#### 2,5

### 03 ロックに関する以下の記述で適切ではないものを２つ選びなさい。
* 1. pg_locksビューのcurrent_query列には、ロックを保持しているクエリが表示される
* 2. pg_locksビューには行ロックを保持しているトランザクションは表示されない
* 3. deadlock_timeoutの値を大きくすると、デッドロックが検出されるまでの時間が長くなる
* 4. deadlock_timeoutの値を大きくすると、デッドロックの誤検知の発生確率が高くなる
* 5. トランザクションが並列実行される状態において、パラメータチューニングによりデッドロックの発生を防止する方法はない
