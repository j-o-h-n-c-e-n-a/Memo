# 参照
* [サンプル問題](https://oss-db.jp/sample)
* [OSS-DB入門](https://oss-db.jp/dojo#dojo_nyumon)
* [オススメ！OSS-DB情報](https://oss-db.jp/dojo#dojo_column)

# OSS-DB Silver
## 一般知識（16％）
### OSS-DBの一般的特徴　【重要度：4】
    PostgreSQLの機能概要、ライセンス、OSSのコミュニティの役割などに関する理解を問う
#### 主要な知識範囲：
* PostgreSQLの機能全般、OSS-DBおよびOSS一般のライセンス、OSS-DBのコミュニティ、活動内容、参加方法など
* 【追加】メジャーバージョン / マイナーバージョン
* 【追加】リリースサイクル / サポートポリシー / バグ報告
#### 重要な用語、コマンド、パラメータなど：
* BSDライセンス
    + 著作権表示は必要
* バージョン：x.y
* メジャーバージョン(x)
    + 機能追加を含んだもの
* マイナーバージョン(y)
    + セキュリティやバグ対応
* 9系：レプリケーションや，OLTP（Online Transaction Processing）とDWH（Data Warehouse）
    + レプリケーション
    + マテリアルズドビュー
    + パラレルクエリ
* 10系：ロジカルレプリケーションとネイティブのパーティション
    + パラレルクエリの強化
    + プッシュダウン
    + パーティション
* 11系：Window関数とパーティションの強化
    + パラレルクエリの強化
    + JITコンパイラ

### リレーショナルデータベースに関する一般知識　【重要度：4】
    リレーショナルデータベースの基本概念、一般的知識を問う
#### 主要な知識範囲：
* リレーショナルデータモデルの基本概念
* データベース管理システムの役割
* SQL に関する一般知識
    + 最新の標準規格：SQL:2016
    + Postgresの対応状況：SQL:2011の一部まで（SQL:2008には完全準拠）
* SQLの 分類 (DDL / DML / DCL) [!]
* データベースの設計と正規化
    + 目的：データの重複を排除することで、データ保守を容易にする
#### 重要な用語、コマンド、パラメータなど：
* DDL(Data Definition Language)
    + CREATE TEBLE
* DML(Data Manipulation Language)
    + UPDATE/DELETE/INSERT
* DCL(Data Control Language)
    + GRANT/REVOKE/COMMIT/ROLLBACK
* 第１正規形
    + 繰り返し項目の除去
* 第２正規形
    + 主キーに対してすべての非キー属性が完全関数従属
* 第３正規形
    + すべての非キー属性がどの候補キーに対しても推移的に関数従属していない


## 運用管理（52％）
### インストール方法　【重要度：2】
    PostgreSQLのインストール方法、データベースクラスタの作成方法などに関する理解を問う
#### 主要な知識範囲：
* initdbコマンドの使い方 [!]
    + https://www.postgresql.jp/document/11/html/app-initdb.html
    + ロケール：--locale
        - デフォルトはOSのロケールを使用
        - バイナリ値を基準にしたい場合、initdb --locale=C または、--no-locale を指定する
    + 文字エンコーディングの指定：--encoding
        - デフォルトは、sql_ascii
        - クライアントの文字セットとして、Shift-JISをサポートしている
        - データベース毎に異なる文字セットを使うことができる（createdbまたはCREATE DATABASE文のオプションで指定）
        - ターミナルでマルチバイト文字を扱えないので、明示的にUTF-8辺りを指定するべき
    + データベースクラスタのディレクトリ指定：--pgdata
    + スーパーユーザのパスワード設定：--pwfile/--pwprompt
* データベースクラスタの概念と構造 [!]
    + テンプレートデータベースを含む、複数のデータベースの集合体
    + デフォルトでは1台のマシン上に構成するが、$PGDATAや受付ポートを複数用意することで複数のデータベースクラスタを稼働させることができる
* テンプレートデータベース [!]
	+ テンプレートデータベースを作成するには、CREATE DATABASEコマンドの実行時にIS_TEMPLATEをtrueに指定します。また、ALTER DATABASEコマンドでIS_TEMPLATEをtrueあるいはfalseに指定することで、通常のデータベースをテンプレートデータベースに変更すること、あるいはその逆が行えます。
    + pg_databaseのdatistemplateがtrueになっているデータベース
    + データベースをテンプレートデータベースにするには、システムカタログpg_databaseのdatistemplateをtrueに設定する
    + CREATEDB権限があれば、複製できる
    + データの更新やデータベース削除などは通常のデータベース同様の処理ができる
    + template0は削除することができない
    + template0は誤って更新されることを防ぐため、pg_databaseのdatallowconnがfalseになっており、スーパーユーザも含め、誰も接続できないようになっている。
#### 重要な用語、コマンド、パラメータなど：
* データベースクラスタ：1つ以上のデータベースと、管理情報・設定ファイルが集まったもの 
    + PostgreSQLは、データベースクラスタ単位で起動・停止を行う 
    + 実体は構築時に指定するPostgreSQL関連の最上位のディレクトリ
       (ディレクトリを指す場合は、「データディレクトリ」と記載される) 
    + 環境変数$PGDATAにデータディレクトリのパスを設定しておく
* initdb：データベースクラスタの初期化 
    + pg_ctl initdb
    + データベースクラスタは、セキュリティ上の理由から、データベースクラスタを作成したユーザ(initdbを実行したデータベース管理者ユーザ)以外は読み書きができないようになっています
* PGDATA
    + initdb -D でも指定可能
* template0：システムの標準オブジェクトのみが含まれる読み取り専用のデータベース
* template1：ひな形データベース(デフォルト)

### 標準付属ツールの使い方 【重要度：5】
    コマンドプロンプトから実行できる管理用ツールの使い方を問う
#### 主要な知識範囲：
* データベース管理用コマンドの使い方
#### 重要な用語、コマンド、パラメータなど：
* pg_ctl [●]
    + サーバーの初期化
    + データベースの起動・停止
    + 設定ファイルの再読み込み
* createuser：データベースユーザの作成 [●]
    + 初期ユーザ(一般にpostgresユーザと表記される)はスーパーユーザ
    + スーパーユーザもしくは CREATEROLE 権限を持っていれば実行でき、OSのユーザアカウントとは無関係
    + ログイン属性を持つユーザを作成 
        - (SQL)CREATE ROLE文
    + オプション：
        - -c: 新しいユーザの最大接続数、デフォルトは無限大
        - -d: 新しいユーザにデータベースの作成権限を付与する
        - -D: 新しいユーザにデータベースの作成権限を付与しない（デフォルト）
        - -r: ユーザ（ロール）作成の権限を与える
        - -s: スーパユーザ権限を与える
* dropuser
* createdb：データベースの作成
* dropdb：データベースの削除
* psql：データベースに接続、SQL発行
    + --list：データベースの一覧を表示（pg_databaseというシステムカタログからも取得可能）
* メタコマンド
    + \で始まる（\hなどがある）
    + \list：データベースの一覧を表示
    + \d テーブル名：テーブルの列名と列属性の一覧を表示
    + \d：テーブル、ビュー、およびシーケンスの一覧を表示

### 設定ファイル 【重要度：5】
    設定ファイルの使い方、基本的な設定パラメータに関する知識を問う
#### 主要な知識範囲：
* postgresql.confに関する以下の4項目
    + 記述方法
    + 接続と認証
    + クライアント接続デフォルト
    + エラー報告とログ取得
* pg_hba.confの設定方法
* SET/SHOWの使い方
    + 有効範囲はセッション単位、あるいはトランザクション単位に限定される
    + LOCALオプションを指定するとトランザクション単位となる
    + lc_messagesなど一部のパラメータの設定変更にはスーパユーザ権限が必要
#### 重要な用語、コマンド、パラメータなど：
* postgresql.conf
    + メモリ関連
        - shared_buffers：共有バッファサイズを指定します。（デフォルト値は32MB）
        - work_mem：内部並び替えとハッシュテーブル操作が使用するメモリーサイズを指定します。（デフォルト値は1MB）
    + WAL関連
        - wal_buffers：WALバッファサイズを設定します。（デフォルト値はshared_buffersの1/32のサイズ）
        - checkpoint_segments：チェックポイントの処理を実行するタイミングをWALセグメントの数で設定します。（デフォルト値は3）
        - checkpoint_timeout：チェックポイントの処理を実行するタイミングを設定しますが、こちらは時間間隔で設定します。（デフォルト値は5m）
    + アクセス制限の指定
        - listen_addresses
    + テーブルスキーマの設定
        - search_path：デフォルトは "$user", public
    + 再起動が必要な設定
        - port
        - max_connection
    + ログ関連
        - log_destination：stderr、csvlog、syslog といった出力方法を指定
        - logging_collector： on にすることで、標準エラー出力に送られたログメッセージをログファイルにリダイレクトできる。
        - log_connections：on にすることで、クライアントからサーバへの接続試行がログに出力される。
        - log_statement：どの SQL 文をログに記録するかを制御するパラメータで、有効な値は none、ddl、mod、all （デフォルトはnone）
        - log_line_prefix：各ログ行の先頭に出力する書式文字列
* pg_hba.conf
    + 接続タイプ、接続先DB、ユーザ名、接続ホスト名、認証方法
    + データベースに接続するときの認証方式を記載
    + アクセス制限の指定
        - セキュリティ上、trust の指定はしないようにする
* pg_ctl reload/restart：設定ファイルの再読み込みと再起動
* 【追加】pg_settings

### バックアップ方法 【重要度：7】
    PostgreSQLのバックアップ方法に関する理解を問う
#### 主要な知識範囲：
* バックアップの種類
    + 論理バックアップ：SQLをそのまま保存する。無停止かつお手軽に実施できるが、バックアップした時点までしか戻せない。
    + 物理バックアップ：サーバを止めてデータファイルをコピーする。多くの場合，論理バックアップより高速に実施できる。バックアップした時点までしか戻せない
* 各種バックアップコマンドの使い方
    + pg_dump / pg_dumpall
* ファイルシステムレベルのバックアップとリストア
    + データベースを停止する必要がある
    + データベースクラスタ全体をバックアップする必要がある
    + 論理バックアップに比べると、ファイルシステムのコピーによるバックアップは一般的に高速である。
* ポイントインタイムリカバリ(PITR)の概念と手順
    + データベースクラスタ全体で動作（特定のデータベースのみをバックアップすることはできない）
    + 無停止でデータファイルとWALアーカイブをコピーする
    + 最新状態までの任意の時点に戻せるが、運用コストは高くなる
* 【追加】トランザクションログ(WAL)とWALアーカイブ [!]
    + 更新内容が書かれている「WALレコード」単位で構成され最大16Mバイト
    + WALレコードにはLSN（Log Sequence Number）とよばれる番号が振られている
    + max_wal_size の値によりファイルの総数が決まり、ファイルの総数に達すると、古いファイルから上書かれていく
    + 上書きによるWALの消失を防ぐために、WALアーカイブファイルとして残すこともできる
    + WALライタプロセスによってWALバッファのデータが書き込まれる
* 【追加】pg_start_backup() / pg_stop_backup()
    + データベースクラスタ全体をtarなどのOS付属のコマンドを利用して物理的にコピーすることでベースバックアップを作成する。このとき、バックアップの取得前後に管理ユーザにて実行する
* COPY文(SQL)、¥copyコマンド(psql)の使い方 [!]
    + 標準SQLにはない、PostgreSQL独自拡張機能
    + テーブルのデータのバックアップやリストアなどに使用することができる
    + ファイルの入出力をする場合は、スーパーユーザ権限が必要だが、TO STDIN/OUTの指定により標準入出力となるので、一般ユーザでも実行できる
    + pg_dumpコマンドで作成したテキスト形式のバックアップからリストアするとき、デフォルトではCOPY文が利用される
#### 重要な用語、コマンド、パラメータなど：
* pg_dump：論理バックアップの取得（SQLコマンドが含まれる場合がある）
    + プレーンテキスト形式（SQL）
    + カスタムアーカイブ形式（圧縮したバイナリ）[●]
    + ディレクトリ形式（表単位で圧縮したバイナリ）
    + TAR形式（表単位のバイナリ）
* pg_dumpall：データベースクラスタ全体のバックアップを取得する
    + テキスト形式のみ
    + グローバルオブジェクトのバックアップが可能
* pg_restore：論理バックアップを利用したリストア（pg_dumpコマンドと並列実行可能）
    + バイナリ形式のバックアップの場合に使用する
* psql
    + テキスト形式のバックアップの場合に使用する
* pg_basebackup：物理バックアップの取得
    + wal_level
    + archive_mode
    + archive_command
* PITR
* 【追加】recovery.conf
    + restore_command
    + recovery_target_time
    + archivecleanup_command
* COPY
    + COPY テーブル名 TO 出力先; 
    + サーバで処理される
    + COPY文ではテーブルしか指定できない制限がある
    + 出力形式のデフォルトはタブ区切りのテキスト形式
    + オプション：
        - FORMAT
        - DELIMITER
* ¥copy
    + クライアントで処理される

### 基本的な運用管理作業 【重要度：7】
    データベース管理者として実行する基本的な運用管理コマンドに関する知識を問う
#### 主要な知識範囲：
* 【追加】PostgreSQLの起動・停止方法
    + PostgreSQLデータベースのサーバプロセスの終了は、データベースの管理者ユーザが行う
    + 停止するときに接続中のセッションをどうするのか終了モードを設定することができる
        - smart/fast/immediate（デフォルトはfast）
* 【追加】データベースロール / ユーザの概念
* 【変更】データベースロール / ユーザの追加・削除・変更方法
* VACUUM、ANALYZEの目的と使い方 
    + 追記型アーキテクチャ：1行の更新であっても、繰り返すことでデータが肥大化していく 
    + VACUUMの目的：不要な行を定期的に削除するVACUUM処理が必要
    + ANALYZEの目的：問い合わせプランナが最適な実行計画を作成するために利用される
* 自動バキュームの概念と動作
    + トランザクションIDの周回問題を回避するために実行される
    + VACUUM、ANALYZEを自動的に実行する
    + デフォルトで有効
    + VACUUMは通常の更新を妨げないよう、該当行にのみ弱いロックを必要とする 
        - VACUUMと競合する処理が明示された場合、VACUUMがキャンセルされる 
        - VACUUMのオプションとして、ロック強度が強く、効果が高いコマンドも存在 
    + データ更新量に依存して起動され、経過時間やデータベース負荷は関係が無い
* システム情報関数
* 情報スキーマとシステムカタログ
    + 情報スキーマ：データベース内のオブジェクトに関する様々な情報を提供する
    + information_schema：情報スキーマは information_schema というスキーマ内のビューとして実現されています。標準SQLの機能として定義されているため、PostgreSQL 以外の RDBMS でも利用でき、ビューの名前、および多くのカラム名は他の RDBMS でも同じ
    + pg_tables：テーブルに関する情報（テーブル名、スキーマ名、所有者）を表示するシステムビューで、一般ユーザでも利用することができる
    + pg_views：ビューに関する情報を表示するシステムビュー
* テーブル単位の権限（GRANT/REVOKE） [!]
    + デフォルトではテーブルの作成者（所有者）のみがすべての権限を所持しており、他のユーザは一切の権限を所持していません
    + スーパーユーザは特殊なユーザで、アクセス権限がなくても、テーブルにアクセスすることができます
    + UPDATE権限だけでなく、WHERE句で参照する列についてのSELECT権限も必要となります
    + テーブル自体を削除(DROP)するのは、テーブルの所有者に限られ、その権限をGRANTで付与することはできない
    + 権限は指定されたユーザに対するものとなり、PUBLICに対して指定があった場合は全体に影響が残る
#### 重要な用語、コマンド、パラメータなど：
* 【追加】pg_ctl start / stop：データベースクラスタの起動と停止
* 【変更】CREATE/ALTER/DROP ROLE/USER
    + ALTER USER：ユーザの属性や権限などを変更する [●]
        - オプションで PASSWORDを指定することで、ユーザのパスワードを設定あるいは変更できます。
        - オプションで VALID UNTILを指定することで、ユーザのパスワードが無効になる日時（タイムスタンプ）を設定あるいは変更できます。
        - オプションで CREATEROLE あるいは NOCREATEROLEを指定することで、新しいユーザを作成する権限の有無を変更できます。
        - オプションで LOGIN あるいは NOLOGINを指定することで、データベースクラスタに接続する権限を変更できます。
        - 内部的にALTER ROLEを実行する
* VACUUM
    + タプルの更新・削除によって使用されなくなったデータ領域を回収する
        - 通常のバキュームは、削除済みになっているデータ領域を更新することで、次にINSERT が実行されたときにその領域にデータが挿入されるようにするものなので、データファイルのサイズは変更されません。
    + FULLオプション：FULLオプションを指定すると、postgresqlは、更新/削除された行の切り詰めを行う。（データファイルサイズが小さくなる）
* ANALYZE
    + テーブル内にどのようなデータが入っているかを調べる
    + テーブルの統計情報を取得して問い合わせの計画の最適化のもとにする
    + オプション指定により、対象を、データベース内の全テーブル、あるいは、データベース内の特定のテーブルのみ、特定のテーブルの特定の列のみ、などに制限できる
* vacuumdb
* 【追加】autovacuum
* current_user：現在のユーザ名を取得 [●]
* version
* information_schema
* GRANT：アクセスを許可する
* REVOKE：許可したアクセス権限を取り消す


## 開発/SQL（32％）
### SQL コマンド 【重要度： 13】
    基本的なSQL文およびデータベースの構成要素に関する知識を問う
#### 主要な知識範囲：
* SELECT 文
* INSERT 文
* UPDATE 文
* DELETE 文
* データ型
    + 数値型
    + 文字列型
    + 日付型
* テーブル定義
* インデックス
* ビュー
* 【追加】マテリアライズドビュー
* ルール
* トリガー
* シーケンス
    + CREATE SEQUENCE
    + テーブルに格納されるデータが連番になるとは限らない
* スキーマ
* 【追加】テーブルスペース
* 【追加】パーティション [!]
    + 条件（日や月単位、地域など）によって、データを複数に分割して格納することができる
    + 頻繁に使うレコードが存在するパーティションをキャッシュ出来る
    + グローバルインデックスはできない
* 関数定義 / 【追加】プロシージャ定義
* PL/pgSQL
* 引用符
    + 一重引用符：文字列リテラル
    + 二重引用符：テーブル名や列名のオブジェクト名に使用
        - 記号を含めたり、大文字と小文字を区別する
#### 重要な用語、コマンド、パラメータなど：
* SELECT/INSERT/UPDATE/DELETE
* FROM
* JOIN
* WHERE
* INTO
* VALUES
* SET [●]
* LIMIT
* OFFSET
* ORDER BY
* DISTINCT
* GROUP BY
* HAVING
* EXISTS
* IN
* NOT
* INTEGER：数値型
* SMALLINT：数値型
* BIGINT：数値型
* NUMERIC：数値型
* DECIMAL：数値型
* REAL [?]：数値型
* DOUBLE PRECISION [?]：数値型
* CHAR：文字列型
* CHARACTER：文字列型
* VARCHAR：文字列型
* CHARACTER VARYING：文字列型
* TEXT：文字列型
* BOOLEAN
* DATE：日付型
* TIME：日付型
* TIMESTAMP：日付型
* INTERVAL [?]
* SERIAL [?]：シーケンス
* BIGSERIAL [?]：シーケンス
* 【追加】BYTEA
* NULL
* CREATE/ALTER/DROP TABLE [●]
* PRIMARY KEY
* FOREIGN KEY
* REFERENCES [?]
* UNIQUE
* NOT NULL
* CHECK
* DEFAULT
* 【追加】CREATE/ALTER/DROP INDEX/VIEW/MATERIALIZED VIEW/RULE/TRIGGER/SCHEMA/SEQUENCE/TABLESPACE/FUNCTION/PROCEDURE
    + TABLESPACE：表領域の作成 [●]
    + FUNCTION：ユーザ定義関数の作成
* 【追加】CREATE TABLE PARTITION BY/OF [●]
* 【追加】ALTER TABLE ATTACH/DETACH PARTITION

### 組み込み関数 【重要度：2】
    データベースで標準的に利用できる関数および演算子に関する知識を問う
#### 主要な知識範囲：
* 集約関数
* 算術関数
* 演算子
* 文字列関数
* 文字列演算子 / 述語
* 時間関数
#### 重要な用語、コマンド、パラメータなど：
* 集約関数：count
* 算術関数：sum
* 算術関数：avg
* 算術関数：max
* 算術関数：min
* 文字列関数：char(character)_length
* 文字列関数：lower
* 文字列関数：upper
* 文字列関数：substring
* 文字列関数：replace
* 文字列関数：trim
* 文字列演算子：||
* 文字列演算子：~
* 文字列演算子：LIKE
* 文字列演算子：SIMILAR TO
* 時間関数：age
* 時間関数：now
* current_date：現在日付のみ取得 [●]
* current_timestamp / 【追加】statement_timestamp / 【追加】clock_timestamp [●]
* current_time：現在時刻のみ取得 [●]
* extract
* to_char

### トランザクションの概念 【重要度：1】
    トランザクション機能に関する知識を問う
* 現実の処理をコンピュータで扱うための考え方 
* ACID特性
    + Atomicity(原子性)
        - トランザクションに含まれる一連の処理は、全体として実行されるか、実行されないかのいずれかであることが保証されるという性質。
        - 何らかの障害により処理が途中で止まってしまった場合、処理途中のデータを格納するのではなく、処理を実行していない状態を維持するということ。
    + Consistency(一貫性)
        - あらかじめ指定したルールに沿った形で処理が行われるという性質。
        - 例えば、あるカラムに対してuniqueという条件を指定した場合に、そのカラム内で重複しないことを保証するもの。
    + Isolation(独立性)
        - ある処理について、外部から見ることができるのは実行前と実行後のデータだけであり、実行中のデータの状態を見ることができないという性質。
    + Durability(永続性)
        - ある処理が完了した段階で、その出力結果は永続的に失われることのないものとしてデータベースに記録されるという性質。
* 適切なロックを獲得する（獲得できない場合は待機する）ことで、同時に同じデータ が複数人から更新されることを防ぎ、また、同時に反映されるべきある一連の更新は、 読み取り一貫性により他者から途中の段階を見られることは無い。 
* 不整合
    + ダーティリード：他のトランザクションが更新した未コミット状態のデータを読み込んでしまうこと。
    + 反復不能読み取り：トランザクション内で同じレコードを2回読み込んだとき、読み込み間隔内に他のトランザクションが該当レコードの更新をコミットしたことで、1回目と2回目の読み込み結果が変わってしまうこと。
    + ファントムリード：トランザクション内で同一条件のレコード抽出を2回行ったとき、読み込み間隔内に他のトランザクションがレコードの挿入/削除をコミットしたことで、1回目と2回目の結果のレコード数が変わってしまうこと。
* ロングトランザクションの弊害
    + ロングトランザクションは長時間にわたりコミットもロールバックも行われないトランザクションを指します。その間、トランザクションの対象となったテーブルはロックされることになり、それが長時間に及ぶとさまざまな弊害が発生します。
    + VACUUMは実行中のトランザクションが参照する可能性のある不要領域を回収できません。
    + トランザクション中に発生しているロックのため、メンテナンス系のコマンドはトランザクション完了まで待たされることになります。
#### 主要な知識範囲：
* トランザクションの構文
* 【変更】トランザクション分離レベル
    + リードアンコミッティド：未コミット状態のデータであっても読み込む
    + リードコミッティド：コミットされたデータのみを読み込む
    + リピータブルリード：トランザクション中は他のトランザクションでコミットされた更新を参照しないことで、同じレコードを繰り返し読んでも常に同じ結果が得られることを保証する
    + シリアライザブル：トランザクションの逐次実行をエミュレートし、直列的に実行した場合と同じ結果になることを保証する
* LOCK 文
* 行ロックとテーブルロック
    + 同じ行に対する更新を防ぐ仕組み 
    + DMLの対象行はロックされ、別トランザクションの操作を待機させる
* 【追加】デッドロック
    + 2つのトランザクションがロックを取り合う状態 
        - 片方がエラーになりトランザクション失敗 
        - 他方はロック待ちが終わり成功
#### 重要な用語、コマンド、パラメータなど：
* BEGIN
* COMMIT
* ROLLBACK
* SAVEPOINT [?]
* SET TRANSACTION
* LOCK TABLE
* 【追加】SELECT FOR UPDATE / SHARE

## その他
### メモリ領域
#### 共有メモリ 
    共有メモリとはすべてのプロセスで共有する領域。
    大きく分けて共有バッファとWALバッファが存在する。
* 共有バッファ 
    + デフォルト値：shared_buffers = 128MB
    + ディスクから読み取ったデータをキャッシュして、以降のユーザ要求に高速に応答 
    + 実メモリが１GB以上の場合は1/4程度。Winodws上では512MB以内に設定
* WALバッファ 
    + デフォルト値：wal_buffers = -1 は shared_buffers の1/32が自動設定
    + ログ先行書き込み(Write Ahead Logging) 
    + 耐障害性とパフォーマンスを両立するための仕組み 
    + WALファイルのサイズと同じ16MBが最大値
#### セッションメモリ 
    セッション毎に確保される領域 
* ワークメモリ 
    + デフォルト値：work_mem = 4MB
    + ソートやハッシュの一時領域。不足すると一時ファイルを作成して処理する
* メンテナンスワークメモリ 
    + デフォルト値：maintenance_work_mem = 64MB
    + メンテナンス操作(バキュームやインデックス作成)に使用

### プロセス
    PostgreSQLではマルチプロセスモデルを採用。
    プロセスは大きく分けてマスタサーバプロセス、バックグラウンドプロセス、バックエンドプロセスが存在する。
#### 必須プロセス 
* postgres(postmaster)、postgres backend 
    + クライアントからの接続を待ち受ける、writer, wal writer, autovacuum launcher, stats collector などのプロセスの親プロセス 
    + postgresプロセスによって起動され、クライアントからの処理を担当 
    + データベースクラスタ1つに対して、postmaster というプロセス
* writer [●]
    + 共有バッファのデータをディスクに書き込むプロセス 
    + チェックポイントやダーティバッファの書き込み 
* wal writer [●]
    + データの変更履歴をWALファイルに書き込む
#### パラメータ設定により起動するプロセス 
* logger [●]
    + PostgreSQLサーバ実行時のログを記録するプロセス 
    + パラメータ設定により有効化し、何をどこに保存するか指定できる 
* archive [●]
    + チェックポイント以前の不要なWALをPITRのために別のディスクに退避 
* autovacuum launcher/worker [●]
    + 自動VACUUMを実行 
* stats collector [●]
    + 実行時統計情報を収集する
#### チューニング
* writer：ライタプロセスによるテーブルファイルへの書き込みが大量に発生すると、問い合わせ性能がおちる
    + bgwriter_delay：ライタプロセスの動作周期
    + bgwriter_lru_maxpages：一度にライタプロセスが書き込むページ数の上限
    + bgwriter_lru_multiplier：書き込みが必要になったページのうち、どのくらいの割合を書き込むべきか計算する際に使用

### プロセスとメモリとファイルの関係
#### WALバッファ -> WALライタプロセス -> WALファイル
* UPDATEなどの更新処理が発生した場合、まずWALバッファに更新情報が書き込まれる
* COMMITを行った契機でWALバッファの情報がWALライタプロセスによってWALファイルに書き込まれる
#### 共有バッファ -> ライタプロセス（or チェックポインタ） -> テーブルファイル・インデックスファイル
* UPDATEなどの更新処理が発生した場合、まず共有バッファ上のデータが更新される
* この更新された情報（ダーティーページ）はすぐにはデータファイルには反映されない 
    + 随時データファイルへの書き込みを行うとI/Oが頻発してパフォーマンス上よろしくない
* ダーティーページのデータファイルへの書き込みはライタプロセスおよびチェックポインタで行われる 
    + 書き込み時はI/Oが発生するので、問い合わせが遅くなる原因にもなる

### 表領域
#### tablespace
* 表と索引を別のディスクに配置することでパフォーマンス向上を図ることができる。
* 表領域としてはディレクトリ名を指定し、そのディレクトリ内に表や索引がファイルとして作成される。
* 表領域を作成していない状態では、すべての表や索引は、データベースクラスタ内の base ディレクトリの下に作成される。
